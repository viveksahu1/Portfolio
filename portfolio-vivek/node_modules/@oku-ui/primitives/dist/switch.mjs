import { shallowRef, defineComponent, watch, openBlock, createElementBlock, unref, createBlock, normalizeProps, guardReactiveProps, withCtx, renderSlot, mergeDefaults } from 'vue';
import { m as mergePrimitiveAttrs, c as convertPropsToHookProps, n as normalizeAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, u as useControllableStateV2, a as useRef } from './hooks.mjs';

const DEFAULT_SWITCH_ROOT_PROPS = {
  as: "button",
  checked: void 0,
  defaultChecked: void 0,
  value: "on",
  required: void 0,
  disabled: void 0
};
const [provideSwitchContext, useSwitchContext] = createContext("Switch");
function useSwitchRoot(props) {
  const {
    disabled = () => void 0,
    required = () => void 0,
    value = () => "on",
    name = () => void 0
  } = props;
  const control = props.control || shallowRef();
  const setElRef = props.control ? void 0 : (value2) => control.value = value2;
  const bubbles = useRef(true);
  const isFormControl = useRef(false);
  const checked = useControllableStateV2(props.checked, props.onUpdateChecked, props.defaultChecked);
  function onClick(event) {
    if (event.defaultPrevented)
      return;
    checked.value = !checked.value;
    if (isFormControl.value) {
      bubbles.value = !event.cancelBubble;
    }
  }
  provideSwitchContext({
    checked,
    disabled,
    bubbleInput: {
      control,
      bubbles,
      isFormControl,
      name,
      value,
      checked,
      required,
      disabled
    }
  });
  return {
    attrs(extraAttrs) {
      const _disabled = disabled();
      const _checked = checked.value;
      const attrs = {
        "elRef": setElRef,
        "type": "button",
        "role": "switch",
        "aria-checked": _checked,
        "aria-required": required(),
        "data-state": _checked ? "checked" : "unchecked",
        "data-disabled": _disabled ? "" : void 0,
        "disabled": _disabled,
        "value": value(),
        onClick
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _hoisted_1 = ["name", "value", "checked", "required"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "SwitchBubbleInput"
  },
  __name: "SwitchBubbleInput",
  setup(__props) {
    const bubbleInput = useSwitchContext("CheckboxBubbleInput").bubbleInput;
    bubbleInput.isFormControl.value = true;
    let input;
    function setElRef(vNode) {
      input = vNode;
    }
    watch(bubbleInput.checked, (checked, prevChecked) => {
      if (!input)
        return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const inputEvent = new Event("input", { bubbles: bubbleInput.bubbles.value });
        const changeEvent = new Event("change", { bubbles: bubbleInput.bubbles.value });
        setChecked.call(input, checked);
        input.dispatchEvent(inputEvent);
        input.dispatchEvent(changeEvent);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("input", {
        ref: setElRef,
        type: "checkbox",
        "aria-hidden": "true",
        tabindex: "-1",
        name: unref(bubbleInput).name(),
        value: unref(bubbleInput).value(),
        checked: unref(bubbleInput).checked.value,
        required: unref(bubbleInput).required(),
        style: {
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }, null, 8, _hoisted_1);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "SwitchRoot",
    inheritAttrs: false
  },
  __name: "SwitchRoot",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    checked: { type: Boolean },
    defaultChecked: { type: Boolean },
    required: { type: Boolean },
    disabled: { type: Boolean },
    value: {},
    name: {}
  }, DEFAULT_SWITCH_ROOT_PROPS),
  emits: ["update:checked"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const switchRoot = useSwitchRoot(convertPropsToHookProps(
      props,
      ["checked", "disabled", "required", "value", "name"],
      () => ({
        onUpdateChecked(checked) {
          emit("update:checked", checked);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(switchRoot).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const DEFAULT_SWITCH_THUMB_PROPS = {
  as: "span"
};
function useSwitchThumb() {
  const context = useSwitchContext("SwitchThumb");
  return {
    attrs(extraAttrs) {
      const attrs = {
        "data-state": context.checked.value ? "checked" : "unchecked"
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "SwitchThumb",
    inheritAttrs: false
  },
  __name: "SwitchThumb",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_SWITCH_THUMB_PROPS),
  setup(__props) {
    const context = useSwitchThumb();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(context).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_SWITCH_ROOT_PROPS as D, _sfc_main$2 as _, useSwitchRoot as a, _sfc_main$1 as b, DEFAULT_SWITCH_THUMB_PROPS as c, useSwitchThumb as d, _sfc_main as e, provideSwitchContext as p, useSwitchContext as u };
//# sourceMappingURL=switch.mjs.map
