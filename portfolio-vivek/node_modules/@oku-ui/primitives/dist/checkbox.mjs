import { shallowRef, watchEffect, onWatcherCleanup, defineComponent, watch, openBlock, createElementBlock, unref, createBlock, normalizeProps, mergeProps, withCtx, renderSlot, createCommentVNode, mergeDefaults, guardReactiveProps } from 'vue';
import { u as usePresence } from './presence.mjs';
import { m as mergePrimitiveAttrs, c as convertPropsToHookProps, n as normalizeAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, u as useControllableStateV2, a as useRef } from './hooks.mjs';

function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}

const DEFAULT_CHECKBOX_ROOT_PROPS = {
  as: "button",
  value: "on",
  checked: void 0,
  defaultChecked: void 0,
  disabled: void 0,
  required: void 0
};
const [provideCheckboxContext, useCheckboxContext] = createContext("Checkbox");
function useCheckboxRoot(props) {
  const {
    disabled = () => void 0,
    required = () => void 0,
    value = () => "on",
    name = () => void 0
  } = props;
  const control = props.control || shallowRef();
  const setElRef = props.control ? void 0 : (value2) => control.value = value2;
  const bubbles = useRef(true);
  const isFormControl = useRef(false);
  const checked = useControllableStateV2(props.checked, props.onUpdateChecked, props.defaultChecked ?? false);
  const initialCheckedStateRef = checked.value;
  watchEffect(() => {
    const form = control.value?.form;
    if (!form)
      return;
    const reset = () => {
      checked.value = initialCheckedStateRef;
    };
    form.addEventListener("reset", reset);
    onWatcherCleanup(() => {
      form.removeEventListener("reset", reset);
    });
  });
  function onKeydown(event) {
    if (event.defaultPrevented)
      return;
    if (event.key === "Enter")
      event.preventDefault();
  }
  function onClick(event) {
    if (event.defaultPrevented)
      return;
    checked.value = isIndeterminate(checked.value) ? true : !checked.value;
    if (!isFormControl.value)
      return;
    bubbles.value = !event.cancelBubble;
  }
  provideCheckboxContext({
    disabled,
    checked,
    bubbleInput: {
      control,
      bubbles,
      isFormControl,
      name,
      value,
      checked,
      defaultChecked: isIndeterminate(props.defaultChecked) ? false : props.defaultChecked,
      required,
      disabled
    }
  });
  return {
    attrs(extraAttrs) {
      const _disabled = disabled();
      const attrs = {
        "elRef": setElRef,
        "type": "button",
        "role": "checkbox",
        "aria-checked": isIndeterminate(checked.value) ? "mixed" : checked.value,
        "aria-required": required(),
        "data-state": getState(checked.value),
        "data-disabled": _disabled ? "" : void 0,
        "disabled": _disabled,
        "value": value(),
        onKeydown,
        onClick
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _hoisted_1 = ["name", "value", "required", "checked"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "CheckboxBubbleInput"
  },
  __name: "CheckboxBubbleInput",
  setup(__props) {
    const bubbleInput = useCheckboxContext("CheckboxBubbleInput").bubbleInput;
    bubbleInput.isFormControl.value = true;
    let input;
    function setElRef(vNode) {
      input = vNode;
    }
    watch(bubbleInput.checked, (checked, prevChecked) => {
      if (!input)
        return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const inputEvent = new Event("input", { bubbles: bubbleInput.bubbles.value });
        const changeEvent = new Event("change", { bubbles: bubbleInput.bubbles.value });
        input.indeterminate = isIndeterminate(checked);
        setChecked.call(input, isIndeterminate(checked) ? false : checked);
        input.dispatchEvent(inputEvent);
        input.dispatchEvent(changeEvent);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("input", {
        ref: setElRef,
        type: "checkbox",
        "aria-hidden": "true",
        name: unref(bubbleInput).name(),
        value: unref(bubbleInput).value(),
        required: unref(bubbleInput).required(),
        tabindex: "-1",
        checked: unref(isIndeterminate)(unref(bubbleInput).checked.value) ? false : unref(bubbleInput).defaultChecked,
        style: {
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }, null, 8, _hoisted_1);
    };
  }
});

const DEFAULT_CHECKBOX_INDICATOR_PROPS = {
  as: "span",
  forceMount: void 0
};
function useCheckboxIndicator(props) {
  const el = props.el || shallowRef();
  const setElRef = props.el ? void 0 : (value) => el.value = value;
  const context = useCheckboxContext("CheckboxIndicator");
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(el, () => isIndeterminate(context.checked.value) || context.checked.value === true);
  const style = {
    pointerEvents: "none"
  };
  return {
    isPresent,
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "data-state": getState(context.checked.value),
        "data-disabled": context.disabled() ? "" : void 0,
        "style": style
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "CheckboxIndicator",
    inheritAttrs: false
  },
  __name: "CheckboxIndicator",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    forceMount: { type: Boolean }
  }, DEFAULT_CHECKBOX_INDICATOR_PROPS),
  setup(__props) {
    const props = __props;
    const checkboxIndicator = useCheckboxIndicator(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(checkboxIndicator).isPresent.value ? (openBlock(), createBlock(unref(Primitive), normalizeProps(mergeProps({ key: 0 }, unref(normalizeAttrs)(unref(checkboxIndicator).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode("", true);
    };
  }
});

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "Checkbox",
    inheritAttrs: false
  },
  __name: "CheckboxRoot",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    checked: { type: [Boolean, String] },
    defaultChecked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    required: { type: Boolean },
    value: {},
    name: {}
  }, DEFAULT_CHECKBOX_ROOT_PROPS),
  emits: ["update:checked"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const checkboxRoot = useCheckboxRoot(convertPropsToHookProps(
      props,
      ["checked", "disabled", "required", "value", "name"],
      () => ({
        onUpdateChecked(checked) {
          emit("update:checked", checked);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(checkboxRoot).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_CHECKBOX_INDICATOR_PROPS as D, _sfc_main$2 as _, _sfc_main$1 as a, DEFAULT_CHECKBOX_ROOT_PROPS as b, useCheckboxContext as c, useCheckboxRoot as d, _sfc_main as e, isIndeterminate as i, provideCheckboxContext as p, useCheckboxIndicator as u };
//# sourceMappingURL=checkbox.mjs.map
