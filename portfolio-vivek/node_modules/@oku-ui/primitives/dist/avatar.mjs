import { unref, getCurrentScope, onScopeDispose, ref, getCurrentInstance, onMounted, computed, watch, shallowRef, watchEffect, onWatcherCleanup, defineComponent, openBlock, createBlock, withCtx, renderSlot, createCommentVNode, toValue as toValue$1, normalizeProps, guardReactiveProps, mergeDefaults } from 'vue';
import { c as convertPropsToHookProps, m as mergePrimitiveAttrs, n as normalizeAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext } from './hooks.mjs';

function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}

function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}

const isClient = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const noop = () => {
};
const isIOS = /* @__PURE__ */ getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}

function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  const filter = (invoke) => {
    const duration = toValue(ms);
    const maxDuration = toValue(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration);
    });
  };
  return filter;
}

function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn
  );
}

const defaultWindow = isClient ? window : void 0;

function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}

function useMounted() {
  const isMounted = ref(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, instance);
  }
  return isMounted;
}

function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}

function useResizeObserver(target, callback, options = {}) {
  const { window = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window && "ResizeObserver" in window);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const _targets = toValue(target);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];
  });
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}

const DEFAULT_AVATAR_ROOT_PROPS = {
  as: "span"
};
const [provideAvatarContext, useAvatarContext] = createContext("Avatar");
function useAvatarRoot() {
  const imageLoadingStatus = shallowRef("idle");
  provideAvatarContext({
    imageLoadingStatus,
    onImageLoadingStatusChange(newStatus) {
      imageLoadingStatus.value = newStatus;
    }
  });
}

const DEFAULT_AVATAR_FALLBACK_PROPS = {
  as: "span"
};
function useAvatarFallback(props = {}) {
  const context = useAvatarContext("AvatarFallback");
  const canRender = shallowRef(props.delayMs === void 0);
  if (isClient) {
    watchEffect(() => {
      if (props.delayMs !== void 0) {
        const timerId = window.setTimeout(() => canRender.value = true, props.delayMs);
        onWatcherCleanup(() => {
          window.clearTimeout(timerId);
        });
      }
    });
  }
  const isOpen = computed(() => canRender && context.imageLoadingStatus.value !== "loaded");
  return {
    isOpen
  };
}

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "AvatarFallback"
  },
  __name: "AvatarFallback",
  props: {
    as: { default: "span" },
    delayMs: {}
  },
  setup(__props) {
    const props = __props;
    const avatarFallback = useAvatarFallback(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(avatarFallback).isOpen.value ? (openBlock(), createBlock(unref(Primitive), {
        key: 0,
        as: _ctx.as
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as"])) : createCommentVNode("", true);
    };
  }
});

function useImageLoadingStatus(src) {
  const loadingStatus = shallowRef("idle");
  if (!isClient)
    return loadingStatus;
  watchEffect(() => {
    const value = toValue$1(src);
    if (!value) {
      loadingStatus.value = "error";
      return;
    }
    let isMounted = true;
    const image = new window.Image();
    const updateStatus = (status) => () => {
      if (!isMounted)
        return;
      loadingStatus.value = status;
    };
    loadingStatus.value = "loading";
    image.onload = updateStatus("loaded");
    image.onerror = updateStatus("error");
    image.src = value;
    onWatcherCleanup(() => {
      isMounted = false;
    });
  });
  return loadingStatus;
}

const DEFAULT_AVATAR_IMAGE_PROPS = {
  as: "img"
};
function useAvatarImage(props = {}) {
  const context = useAvatarContext("AvatarImage");
  const imageLoadingStatus = useImageLoadingStatus(props.src);
  function handleLoadingStatusChange(status) {
    props.onLoadingStatusChange?.(status);
    context.onImageLoadingStatusChange(status);
  }
  watchEffect(() => {
    if (imageLoadingStatus.value !== "idle") {
      handleLoadingStatusChange(imageLoadingStatus.value);
    }
  });
  return {
    attrs(extraAttrs) {
      const attrs = {
        src: props.src?.(),
        hidden: imageLoadingStatus.value !== "loaded"
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "AvatarImage",
    inheritAttrs: false
  },
  __name: "AvatarImage",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    src: {}
  }, DEFAULT_AVATAR_IMAGE_PROPS),
  emits: ["loadingStatusChange"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const avatarImage = useAvatarImage(convertPropsToHookProps(
      props,
      ["src"],
      () => ({
        onLoadingStatusChange(status) {
          emit("loadingStatusChange", status);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(avatarImage).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "AvatarRoot"
  },
  __name: "AvatarRoot",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_AVATAR_ROOT_PROPS),
  setup(__props) {
    useAvatarRoot();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), { as: _ctx.as }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as"]);
    };
  }
});

export { DEFAULT_AVATAR_FALLBACK_PROPS as D, _sfc_main$2 as _, isIOS as a, useDebounceFn as b, useAvatarFallback as c, DEFAULT_AVATAR_IMAGE_PROPS as d, useAvatarImage as e, _sfc_main$1 as f, DEFAULT_AVATAR_ROOT_PROPS as g, useAvatarContext as h, isClient as i, useAvatarRoot as j, _sfc_main as k, provideAvatarContext as p, tryOnScopeDispose as t, useResizeObserver as u };
//# sourceMappingURL=avatar.mjs.map
