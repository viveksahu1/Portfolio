import { arrow as arrow$1, computePosition } from '@floating-ui/dom';
import { toValue, watchEffect, shallowRef, onWatcherCleanup, computed } from 'vue';

function arrow(options) {
  return {
    name: "arrow",
    options,
    fn(state) {
      const element = toValue(options.element);
      if (element == null) {
        return {};
      }
      return arrow$1({ element, padding: options.padding }).fn(state);
    }
  };
}

function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}

function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}

function useFloating(options, config = {}) {
  let configValue;
  watchEffect(() => {
    const shouldUpdate = configValue !== void 0;
    configValue = toValue(config);
    if (shouldUpdate) {
      update();
    }
  });
  const {
    transform = true,
    whileElementsMounted,
    elements: {
      referenceEl,
      floatingEl
    }
  } = options;
  const x = shallowRef(0);
  const y = shallowRef(0);
  const strategy = shallowRef(configValue.strategy ?? "absolute");
  const placement = shallowRef(configValue.placement ?? "bottom");
  const middlewareData = shallowRef({});
  const isPositioned = shallowRef(false);
  let referenceRef;
  let floatingRef;
  function update() {
    if (!referenceRef || !floatingRef)
      return;
    const config2 = {
      placement: configValue.placement,
      strategy: configValue.strategy,
      middleware: configValue.middleware
    };
    if (configValue.platform)
      config2.platform = configValue.platform;
    computePosition(referenceRef, floatingRef, config2).then(
      (data) => {
        x.value = data.x;
        y.value = data.y;
        strategy.value = data.strategy;
        placement.value = data.placement;
        middlewareData.value = data.middlewareData;
        isPositioned.value = true;
      }
    );
  }
  watchEffect(() => {
    if (referenceEl.value)
      referenceRef = referenceEl.value;
    if (floatingEl.value)
      floatingRef = floatingEl.value;
    if (!referenceEl.value || !floatingEl.value)
      return;
    if (!whileElementsMounted) {
      update();
      return;
    }
    onWatcherCleanup(whileElementsMounted(referenceEl.value, floatingEl.value, update));
  });
  const floatingStyles = computed(() => {
    const initialStyles = {
      position: strategy.value,
      left: 0,
      top: 0
    };
    const floating = floatingEl.value;
    if (!floating)
      return initialStyles;
    const xVal = roundByDPR(floating, x.value);
    const yVal = roundByDPR(floating, y.value);
    if (transform) {
      return {
        ...initialStyles,
        transform: `translate(${xVal}px, ${yVal}px)`,
        ...getDPR(floating) >= 1.5 && { willChange: "transform" }
      };
    }
    return {
      position: strategy.value,
      left: `${xVal}px`,
      top: `${yVal}px`
    };
  });
  return {
    x,
    y,
    strategy,
    placement,
    middlewareData,
    isPositioned,
    floatingStyles,
    update
  };
}

export { arrow as a, useFloating as u };
//# sourceMappingURL=floating.mjs.map
