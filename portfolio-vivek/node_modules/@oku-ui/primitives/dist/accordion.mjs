import { computed, defineComponent, openBlock, createBlock, unref, normalizeProps, guardReactiveProps, withCtx, renderSlot, createCommentVNode, mergeDefaults } from 'vue';
import { u as useCollapsibleRoot, D as DEFAULT_COLLAPSIBLE_CONTENT_PROPS, a as useCollapsibleContent, b as useCollapsibleTrigger } from './collapsible.mjs';
import { m as mergePrimitiveAttrs, c as convertPropsToHookProps, n as normalizeAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, u as useControllableStateV2, a as useRef, b as useId } from './hooks.mjs';
import { u as useDirection } from './direction.mjs';
import { c as createCollection, D as DATA_COLLECTION_ITEM } from './collection.mjs';

const DEFAULT_ACCORDION_ROOT_PROPS = {
  collapsible: void 0,
  disabled: void 0
};
const ACCORDION_KEYS = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"];
const [Collection, useCollection] = createCollection("Accordion");
const [provideAccordionContext, useAccordionContext] = createContext("AccordionContext");
const TYPE_MULTIPLE = "multiple";
function useAccordionRoot(props) {
  const isMultiple = props.type === TYPE_MULTIPLE;
  const {
    orientation = "vertical",
    defaultValue = isMultiple ? [] : void 0
  } = props;
  const direction = useDirection(props.dir);
  const value = useControllableStateV2(
    props.value,
    props.onUpdateValue,
    defaultValue
  );
  const elRef = props.elRef || useRef();
  const setElRef = props.elRef ? void 0 : (value2) => elRef.value = value2;
  const getItems = useCollection(Collection.provideCollectionContext(elRef));
  function onKeydown(event) {
    if (event.defaultPrevented)
      return;
    if (!ACCORDION_KEYS.includes(event.key))
      return;
    const target = event.target;
    const triggerCollection = getItems().filter((item) => !item.disabled);
    const triggerIndex = triggerCollection.findIndex((item) => item === target);
    const triggerCount = triggerCollection.length;
    if (triggerIndex === -1)
      return;
    event.preventDefault();
    let nextIndex = triggerIndex;
    const homeIndex = 0;
    const endIndex = triggerCount - 1;
    const moveNext = () => {
      nextIndex = triggerIndex + 1;
      if (nextIndex > endIndex) {
        nextIndex = homeIndex;
      }
    };
    const movePrev = () => {
      nextIndex = triggerIndex - 1;
      if (nextIndex < homeIndex) {
        nextIndex = endIndex;
      }
    };
    switch (event.key) {
      case "Home":
        nextIndex = homeIndex;
        break;
      case "End":
        nextIndex = endIndex;
        break;
      case "ArrowRight":
        if (orientation === "horizontal") {
          if (direction.value === "ltr") {
            moveNext();
          } else {
            movePrev();
          }
        }
        break;
      case "ArrowDown":
        if (orientation === "vertical") {
          moveNext();
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal") {
          if (direction.value === "ltr") {
            movePrev();
          } else {
            moveNext();
          }
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical") {
          movePrev();
        }
        break;
    }
    const clampedIndex = nextIndex % triggerCount;
    triggerCollection[clampedIndex]?.focus();
  }
  provideAccordionContext({
    id: useId(),
    collapsible: props.collapsible,
    disabled: props.disabled,
    direction,
    orientation: orientation ?? "vertical",
    value: isMultiple ? value : computed(() => value.value ? [value.value] : []),
    onItemOpen: isMultiple ? (itemValue) => {
      value.value = [...value.value || [], itemValue];
    } : (itemValue) => {
      value.value = itemValue;
    },
    onItemClose: isMultiple ? (itemValue) => {
      value.value = (value.value || []).filter((value2) => value2 !== itemValue);
    } : () => {
      if (props.collapsible) {
        value.value = "";
      }
    }
  });
  return {
    attrs(extraAttrs) {
      const _disabled = props.disabled?.();
      const attrs = {
        "elRef": setElRef,
        "data-disabled": _disabled ? "" : void 0,
        "data-orientation": orientation,
        "onKeydown": onKeydown
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const DEFAULT_ACCORDION_ITEM_PROPS = {
  disabled: void 0
};
const [provideAccordionItemContext, useAccordionItemContext] = createContext("AccordionItem");
function useAccordionItem(props) {
  const context = useAccordionContext("AccordionItem");
  const open = computed(() => {
    const value = props.value();
    return value && context.value.value.includes(value) || false;
  });
  const disabled = computed(() => context.disabled?.() || props.disabled?.());
  function onUpdateOpen(open2) {
    if (open2)
      context.onItemOpen(props.value());
    else
      context.onItemClose(props.value());
  }
  provideAccordionItemContext({
    open,
    disabled,
    triggerId: useId()
  });
  const collapsibleRoot = useCollapsibleRoot({
    open() {
      return open.value;
    },
    onUpdateOpen,
    disabled() {
      return disabled.value;
    }
  });
  return {
    attrs(extraAttrs = []) {
      const collapsibleRootAttrs = {
        "data-orientation": context.orientation
      };
      return collapsibleRoot.attrs([collapsibleRootAttrs, ...extraAttrs]);
    }
  };
}

const DEFAULT_ACCORDION_CONTENT_PROPS = DEFAULT_COLLAPSIBLE_CONTENT_PROPS;
function useAccordionContent(props) {
  const collapsibleContent = useCollapsibleContent(props);
  const accordionContext = useAccordionContext("AccordionContent");
  const itemContext = useAccordionItemContext("AccordionContent");
  const style = {
    "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
    "--radix-accordion-content-width": "var(--radix-collapsible-content-width)"
  };
  return {
    isOpen: collapsibleContent.isOpen,
    attrs(extraAttrs = []) {
      const attrs = {
        "role": "region",
        "aria-labelledby": itemContext.triggerId,
        "data-orientation": accordionContext.orientation,
        "style": style
      };
      mergePrimitiveAttrs(attrs, [collapsibleContent.attrs(), ...extraAttrs]);
      return attrs;
    }
  };
}

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "AccordionContent",
    inheritAttrs: false
  },
  __name: "AccordionContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_ACCORDION_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const accordionContent = useAccordionContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(accordionContent).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          unref(accordionContent).isOpen.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16);
    };
  }
});

function useAccordionHeader() {
  const accordionContext = useAccordionContext("AccordionHeader");
  const itemContext = useAccordionItemContext("AccordionHeader");
  return {
    attrs(extraAttrs) {
      const attrs = {
        "data-orientation": accordionContext.orientation,
        "data-state": itemContext.open.value ? "open" : "closed",
        "data-disabled": itemContext.disabled.value ? "" : void 0
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "AccordionHeader",
    inheritAttrs: false
  },
  __name: "AccordionHeader",
  props: {
    as: { default: "h3" }
  },
  setup(__props) {
    const accordionHeader = useAccordionHeader();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(accordionHeader).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "AccordionItem",
    inheritAttrs: false
  },
  __name: "AccordionItem",
  props: /* @__PURE__ */ mergeDefaults({
    disabled: { type: Boolean },
    value: {}
  }, DEFAULT_ACCORDION_ITEM_PROPS),
  setup(__props) {
    const props = __props;
    const accordionItem = useAccordionItem(convertPropsToHookProps(props, ["value", "disabled"]));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(accordionItem).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "AccordionRoot",
    inheritAttrs: false
  },
  __name: "AccordionRoot",
  props: /* @__PURE__ */ mergeDefaults({
    type: {},
    value: {},
    defaultValue: {},
    collapsible: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {}
  }, DEFAULT_ACCORDION_ROOT_PROPS),
  emits: ["update:value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const accordionRoot = useAccordionRoot(convertPropsToHookProps(
      props,
      ["value", "disabled", "dir"],
      () => ({
        onUpdateValue(value) {
          emit("update:value", value);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(accordionRoot).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

function useAccordionTrigger() {
  const collapsibleTrigger = useCollapsibleTrigger();
  const accordionContext = useAccordionContext("AccordionTrigger");
  const itemContext = useAccordionItemContext("AccordionHeader");
  return {
    attrs(extraAttrs = []) {
      const collapsibleTriggerAttrs = {
        "id": itemContext.triggerId,
        "aria-disabled": itemContext.open.value && !accordionContext.collapsible || void 0,
        "data-orientation": accordionContext.orientation,
        [DATA_COLLECTION_ITEM]: true
      };
      return collapsibleTrigger.attrs([collapsibleTriggerAttrs, ...extraAttrs]);
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "AccordionTrigger",
    inheritAttrs: false
  },
  __name: "AccordionTrigger",
  props: {
    as: { default: "button" }
  },
  setup(__props) {
    const accordionTrigger = useAccordionTrigger();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(accordionTrigger).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_ACCORDION_CONTENT_PROPS as D, _sfc_main$4 as _, _sfc_main$3 as a, DEFAULT_ACCORDION_ITEM_PROPS as b, useAccordionItemContext as c, _sfc_main$2 as d, DEFAULT_ACCORDION_ROOT_PROPS as e, provideAccordionContext as f, useAccordionContext as g, _sfc_main$1 as h, _sfc_main as i, provideAccordionItemContext as p, useAccordionContent as u };
//# sourceMappingURL=accordion.mjs.map
