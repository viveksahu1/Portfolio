import { shallowRef, computed, onMounted, nextTick, defineComponent, openBlock, createBlock, unref, normalizeProps, guardReactiveProps, withCtx, renderSlot, createCommentVNode, mergeDefaults } from 'vue';
import { u as usePresence } from './presence.mjs';
import { m as mergePrimitiveAttrs, c as convertPropsToHookProps, n as normalizeAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, u as useControllableStateV2, b as useId } from './hooks.mjs';

const DEFAULT_COLLAPSIBLE_ROOT_PROPS = {
  defaultOpen: void 0,
  open: void 0,
  disabled: void 0
};
const [provideCollapsibleContext, useCollapsibleContext] = createContext("Collapsible");
function useCollapsibleRoot(props) {
  const {
    disabled = () => void 0,
    defaultOpen = false
  } = props;
  const open = useControllableStateV2(props.open, props.onUpdateOpen, defaultOpen);
  provideCollapsibleContext({
    contentId: useId(),
    disabled,
    open,
    onOpenToggle() {
      open.value = !open.value;
    }
  });
  return {
    attrs(extraAttrs) {
      const attrs = {
        "data-state": open.value ? "open" : "closed",
        "data-disabled": disabled() ? "" : void 0
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const DEFAULT_COLLAPSIBLE_CONTENT_PROPS = {
  forceMount: void 0
};
function useCollapsibleContent(props) {
  const el = props.el || shallowRef();
  const setElRef = props.el ? void 0 : (value) => el.value = value;
  const context = useCollapsibleContext("CollapsibleContent");
  let originalStyles;
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(el, context.open, () => {
    const node = el.value;
    if (!node)
      return;
    const nodeStyle = node.style;
    originalStyles = originalStyles || {
      transitionDuration: nodeStyle.transitionDuration,
      animationName: nodeStyle.animationName
    };
    nodeStyle.transitionDuration = "0s";
    nodeStyle.animationName = "none";
    const rect = node.getBoundingClientRect();
    nodeStyle.setProperty("--radix-collapsible-content-height", `${rect.height}px`);
    nodeStyle.setProperty("--radix-collapsible-content-width", `${rect.width}px`);
    nodeStyle.transitionDuration = originalStyles.transitionDuration;
    nodeStyle.animationName = originalStyles.animationName;
  });
  const isOpen = computed(() => isPresent.value || context.open.value);
  const _isOpen = isOpen.value;
  const lockAnimationStyles = shallowRef(
    _isOpen ? { transitionDuration: "0s !important", animationName: "none !important" } : void 0
  );
  onMounted(async () => {
    if (!_isOpen)
      return;
    const node = el.value;
    if (!node)
      return;
    lockAnimationStyles.value = void 0;
    await nextTick();
    const nodeStyle = node.style;
    originalStyles = originalStyles || {
      transitionDuration: nodeStyle.transitionDuration,
      animationName: nodeStyle.animationName
    };
    nodeStyle.transitionDuration = "0s";
    nodeStyle.animationName = "none";
    const rect = node.getBoundingClientRect();
    nodeStyle.setProperty("--radix-collapsible-content-height", `${rect.height}px`);
    nodeStyle.setProperty("--radix-collapsible-content-width", `${rect.width}px`);
  });
  return {
    isOpen,
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "id": context.contentId,
        "data-state": context.open.value ? "open" : "closed",
        "data-disabled": context.disabled() ? "" : void 0,
        "hidden": !isOpen.value,
        "style": {
          "--radix-collapsible-content-height": "0px",
          "--radix-collapsible-content-width": "0px",
          ...lockAnimationStyles.value
        }
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "CollapsibleContent",
    inheritAttrs: false
  },
  __name: "CollapsibleContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_COLLAPSIBLE_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const collapsibleContent = useCollapsibleContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(collapsibleContent).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          unref(collapsibleContent).isOpen.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "CollapsibleRoot",
    inheritAttrs: false
  },
  __name: "CollapsibleRoot",
  props: /* @__PURE__ */ mergeDefaults({
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    disabled: { type: Boolean }
  }, DEFAULT_COLLAPSIBLE_ROOT_PROPS),
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const collapsibleRoot = useCollapsibleRoot(convertPropsToHookProps(
      props,
      ["disabled", "open"],
      () => ({
        onUpdateOpen(value) {
          emit("update:open", value);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(collapsibleRoot).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

function useCollapsibleTrigger() {
  const context = useCollapsibleContext("CollapsibleTrigger");
  function onClick(event) {
    if (event.defaultPrevented)
      return;
    context.onOpenToggle();
  }
  return {
    attrs(extraAttrs) {
      const _disabled = context.disabled();
      const _open = context.open.value;
      const attrs = {
        "type": "button",
        "aria-controls": context.contentId,
        "aria-expanded": _open,
        "data-state": _open ? "open" : "closed",
        "data-disabled": _disabled ? "" : void 0,
        "disabled": _disabled,
        "onClick": onClick
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "CollapsibleTrigger",
    inheritAttrs: false
  },
  __name: "CollapsibleTrigger",
  props: {
    as: { default: "button" }
  },
  setup(__props) {
    const collapsibleTrigger = useCollapsibleTrigger();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(collapsibleTrigger).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_COLLAPSIBLE_CONTENT_PROPS as D, _sfc_main$2 as _, useCollapsibleContent as a, useCollapsibleTrigger as b, DEFAULT_COLLAPSIBLE_ROOT_PROPS as c, useCollapsibleContext as d, _sfc_main$1 as e, _sfc_main as f, provideCollapsibleContext as p, useCollapsibleRoot as u };
//# sourceMappingURL=collapsible.mjs.map
