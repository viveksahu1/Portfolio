import { useId, defineComponent, openBlock, createElementBlock, normalizeProps, guardReactiveProps, unref, createVNode, withCtx, renderSlot, createBlock, createCommentVNode, mergeDefaults, onMounted } from 'vue';
import { f as useMenuContent, a as useMenuRoot, b as useMenuContentImpl, c as useMenuSub, d as useMenuSubContent, e as useMenuSubContentImpl } from './menu.mjs';
import { c as convertPropsToHookProps, n as normalizeAttrs, m as mergePrimitiveAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, u as useControllableStateV2, a as useRef } from './hooks.mjs';
import { u as usePopperContext } from './popper.mjs';

const DEFAULT_DROPDOWN_MENU_CONTENT_PROPS = {
  forceMount: void 0
};
const useDropdownMenuContent = useMenuContent;

const DEFAULT_DROPDOWN_MENU_ROOT_PROPS = {
  open: void 0,
  defaultOpen: void 0,
  modal: void 0
};
const [provideDropdownMenuContext, useDropdownMenuContext] = createContext("DropdownMenu");
function useDropdownMenuRoot(props = {}) {
  const {
    defaultOpen = false,
    modal = true
  } = props;
  const triggerRef = useRef();
  const open = useControllableStateV2(props.open, props.onUpdateOpen, defaultOpen);
  provideDropdownMenuContext({
    triggerId: useId(),
    triggerRef,
    contentId: useId(),
    open() {
      return open.value;
    },
    onOpenChange(value) {
      open.value = value;
    },
    onOpenToggle() {
      open.value = !open.value;
    },
    modal
  });
  useMenuRoot({
    open() {
      return open.value;
    },
    onUpdateOpen(v) {
      open.value = v;
    },
    dir: props.dir,
    modal
  });
}

function useDropdownMenuContentImpl(props = {}) {
  const context = useDropdownMenuContext("DropdownMenuContent");
  let hasInteractedOutsideRef = false;
  const menuContentImpl = useMenuContentImpl({
    ...props,
    onCloseAutoFocus(event) {
      props.onCloseAutoFocus?.(event);
      if (event.defaultPrevented)
        return;
      if (!hasInteractedOutsideRef) {
        context.triggerRef.value?.focus();
      }
      hasInteractedOutsideRef = false;
      event.preventDefault();
    },
    onInteractOutside(event) {
      props.onInteractOutside?.(event);
      if (event.defaultPrevented)
        return;
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (!context.modal || isRightClick)
        hasInteractedOutsideRef = true;
    }
  });
  const style = {
    "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
    "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
    "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
    "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
    "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
  };
  return {
    wrapperAttrs: menuContentImpl.wrapperAttrs,
    attrs(extraAttrs = []) {
      const menuContentImplAttrs = {
        "id": context.contentId,
        "aria-labelledby": context.triggerId,
        style
      };
      return menuContentImpl.attrs([menuContentImplAttrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DropdownMenuContentImpl",
    inheritAttrs: false
  },
  __name: "DropdownMenuContentImpl",
  props: {
    loop: { type: Boolean, default: false },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: { type: Boolean, default: true },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean, default: false },
    updatePositionStrategy: {}
  },
  emits: ["closeAutoFocus", "entryFocus", "escapeKeydown", "pointerdownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const menuContentImpl = useDropdownMenuContentImpl(convertPropsToHookProps(
      props,
      ["collisionBoundary"],
      () => ({
        onCloseAutoFocus(event) {
          emit("closeAutoFocus", event);
        },
        onEntryFocus(event) {
          emit("entryFocus", event);
        },
        onEscapeKeydown(event) {
          emit("escapeKeydown", event);
        },
        onPointerdownOutside(event) {
          emit("pointerdownOutside", event);
        },
        onFocusOutside(event) {
          emit("focusOutside", event);
        },
        onInteractOutside(event) {
          emit("interactOutside", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", normalizeProps(guardReactiveProps(unref(menuContentImpl).wrapperAttrs())), [
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menuContentImpl).attrs([_ctx.$attrs])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16)
      ], 16);
    };
  }
});

const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DropdownMenuContent"
  },
  __name: "DropdownMenuContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_DROPDOWN_MENU_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const dropdownMenuContent = useDropdownMenuContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(dropdownMenuContent).isPresent.value ? (openBlock(), createBlock(_sfc_main$6, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DropdownMenuRoot",
    inheritAttrs: false
  },
  __name: "DropdownMenuRoot",
  props: /* @__PURE__ */ mergeDefaults({
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    dir: {},
    modal: { type: Boolean }
  }, DEFAULT_DROPDOWN_MENU_ROOT_PROPS),
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useDropdownMenuRoot(convertPropsToHookProps(
      props,
      ["open", "dir"],
      () => ({
        onUpdateOpen(open) {
          emit("update:open", open);
        }
      })
    ));
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const DEFAULT_DROPDOWN_MENU_SUB_PROPS = {
  open: void 0,
  defaultOpen: void 0
};
function useDropdownMenuSub(props = {}) {
  const { defaultOpen = false } = props;
  const open = useControllableStateV2(props.open, props.onUpdateOpen, defaultOpen);
  useMenuSub({
    open() {
      return open.value;
    },
    onUpdateOpen(v) {
      open.value = v;
    }
  });
}

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DropdownMenuSub",
    inheritAttrs: false
  },
  __name: "DropdownMenuSub",
  props: /* @__PURE__ */ mergeDefaults({
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  }, DEFAULT_DROPDOWN_MENU_SUB_PROPS),
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useDropdownMenuSub(convertPropsToHookProps(
      props,
      ["open"],
      () => ({
        onUpdateOpen(open) {
          emit("update:open", open);
        }
      })
    ));
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const DEFAULT_DROPDOWN_MENU_SUB_CONTENT_PROPS = {
  forceMount: void 0
};
const useDropdownMenuSubContent = useMenuSubContent;

const DEFAULT_DROPDOWN_MENU_SUB_CONTENT_IMPL_PROPS = {
  avoidCollisions: void 0,
  hideWhenDetached: void 0,
  loop: void 0
};
function useDropdownMenuSubContentImpl(props = {}) {
  const menuSubContentImpl = useMenuSubContentImpl(props);
  const attrs = {
    style: {
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  };
  return {
    wrapperAttrs: menuSubContentImpl.wrapperAttrs,
    attrs(extraAttrs = []) {
      return menuSubContentImpl.attrs([attrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DropdownMenuSubContentImpl",
    inheritAttrs: false
  },
  __name: "DropdownMenuSubContentImpl",
  props: /* @__PURE__ */ mergeDefaults({
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {}
  }, DEFAULT_DROPDOWN_MENU_SUB_CONTENT_IMPL_PROPS),
  emits: ["escapeKeydown", "pointerdownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const menuSubContentImpl = useDropdownMenuSubContentImpl(convertPropsToHookProps(
      props,
      ["collisionBoundary"],
      () => ({
        onEscapeKeydown(event) {
          emit("escapeKeydown", event);
        },
        onPointerdownOutside(event) {
          emit("pointerdownOutside", event);
        },
        onFocusOutside(event) {
          emit("focusOutside", event);
        },
        onInteractOutside(event) {
          emit("interactOutside", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", normalizeProps(guardReactiveProps(unref(menuSubContentImpl).wrapperAttrs())), [
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menuSubContentImpl).attrs([_ctx.$attrs])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16)
      ], 16);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DropdownMenuSubContent"
  },
  __name: "DropdownMenuSubContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_DROPDOWN_MENU_SUB_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const menuContent = useDropdownMenuSubContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(menuContent).isPresent.value ? (openBlock(), createBlock(_sfc_main$2, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const DEFAULT_DROPDOWN_MENU_TRIGGER_PROPS = {
  as: "button",
  disabled: void 0
};
function useDropdownMenuTrigger(props = {}) {
  const context = useDropdownMenuContext("DropdownMenuTrigger");
  const popperContext = usePopperContext("DropdownMenuTrigger");
  function onPointerdown(event) {
    if (event.defaultPrevented)
      return;
    if (event.button === 0 && event.ctrlKey === false) {
      const isOpen = context.open();
      context.onOpenToggle();
      if (!isOpen)
        event.preventDefault();
    }
  }
  function onKeydown(event) {
    if (event.defaultPrevented)
      return;
    if (["Enter", " "].includes(event.key))
      context.onOpenToggle();
    if (event.key === "ArrowDown")
      context.onOpenChange(true);
    if (["Enter", " ", "ArrowDown"].includes(event.key))
      event.preventDefault();
  }
  function setElRef(el) {
    context.triggerRef.value = el;
  }
  onMounted(() => {
    popperContext.onAnchorChange(context.triggerRef.value);
  });
  return {
    attrs(extraAttrs) {
      const _open = context.open();
      const _disabled = props.disabled?.();
      const attrs = {
        "elRef": setElRef,
        "id": context.triggerId,
        "type": "button",
        "aria-haspopup": "menu",
        "aria-expanded": _open,
        "aria-controls": _open ? context.contentId : void 0,
        "data-disabled": _disabled ? "" : void 0,
        "disabled": _disabled,
        onPointerdown,
        onKeydown
      };
      if (extraAttrs && extraAttrs.length > 0)
        mergePrimitiveAttrs(attrs, extraAttrs);
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "DropdownMenuTrigger"
  },
  __name: "DropdownMenuTrigger",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    disabled: { type: Boolean }
  }, DEFAULT_DROPDOWN_MENU_TRIGGER_PROPS),
  setup(__props) {
    const props = __props;
    const dropdownMenuTrigger = useDropdownMenuTrigger(convertPropsToHookProps(props, ["disabled"]));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(dropdownMenuTrigger).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_DROPDOWN_MENU_CONTENT_PROPS as D, _sfc_main$5 as _, DEFAULT_DROPDOWN_MENU_ROOT_PROPS as a, useDropdownMenuContext as b, _sfc_main$4 as c, DEFAULT_DROPDOWN_MENU_SUB_PROPS as d, useDropdownMenuSub as e, _sfc_main$3 as f, DEFAULT_DROPDOWN_MENU_SUB_CONTENT_PROPS as g, useDropdownMenuSubContent as h, _sfc_main$1 as i, DEFAULT_DROPDOWN_MENU_SUB_CONTENT_IMPL_PROPS as j, useDropdownMenuSubContentImpl as k, DEFAULT_DROPDOWN_MENU_TRIGGER_PROPS as l, useDropdownMenuTrigger as m, _sfc_main as n, provideDropdownMenuContext as p, useDropdownMenuContent as u };
//# sourceMappingURL=dropdown-menu.mjs.map
