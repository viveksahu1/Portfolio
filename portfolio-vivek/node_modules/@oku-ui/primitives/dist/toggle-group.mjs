import { computed, toValue, defineComponent, openBlock, createBlock, unref, normalizeProps, guardReactiveProps, withCtx, renderSlot, mergeDefaults } from 'vue';
import { u as useToggle } from './toggle.mjs';
import { u as useRovingFocusGroupRoot, a as useRovingFocusGroupItem } from './roving-focus.mjs';
import { m as mergePrimitiveAttrs, c as convertPropsToHookProps, n as normalizeAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, u as useControllableStateV2 } from './hooks.mjs';
import { u as useDirection } from './direction.mjs';

const DEFAULT_TOGGLE_GROUP_PROPS = {
  disabled: void 0,
  rovingFocus: void 0,
  loop: void 0
};
const [provideToggleGroupContext, useToggleGroupContext] = createContext("ToggleGroup");
const TYPE_MULTIPLE = "multiple";
function useToggleGroup(props) {
  const isMultiple = props.type === TYPE_MULTIPLE;
  const {
    disabled = () => void 0,
    rovingFocus = true,
    loop = true,
    defaultValue = isMultiple ? [] : void 0
  } = props;
  const value = useControllableStateV2(
    props.value,
    props.onUpdateValue,
    defaultValue
  );
  const direction = useDirection(props.dir);
  provideToggleGroupContext({
    type: props.type,
    value: isMultiple ? value : computed(() => value.value ? [value.value] : []),
    onItemActivate: isMultiple ? (itemValue) => {
      value.value = [...value.value || [], itemValue];
    } : (itemValue) => {
      value.value = itemValue;
    },
    onItemDeactivate: isMultiple ? (itemValue) => {
      value.value = (value.value || []).filter((value2) => value2 !== itemValue);
    } : () => {
      value.value = "";
    },
    rovingFocus,
    disabled
  });
  const rovingFocusGroupRoot = rovingFocus ? useRovingFocusGroupRoot({
    orientation: props.orientation,
    dir: direction,
    loop
  }) : void 0;
  return {
    attrs(extraAttrs = []) {
      const primitiveAttrs = {
        role: "group",
        dir: direction.value
      };
      if (rovingFocusGroupRoot) {
        return rovingFocusGroupRoot.attrs([primitiveAttrs, ...extraAttrs]);
      }
      if (extraAttrs.length > 0) {
        mergePrimitiveAttrs(primitiveAttrs, extraAttrs);
      }
      return primitiveAttrs;
    }
  };
}

const DEFAULT_TOGGLE_GROUP_ITEM_PROPS = {
  as: "button",
  disabled: void 0
};
function useToggleGroupItem(props) {
  const context = useToggleGroupContext("ToggleGroupItem");
  const pressed = computed(() => {
    const _value = toValue(props.value);
    return context.value.value.includes(_value);
  });
  const disabled = computed(() => context.disabled() || props.disabled?.());
  const toggle = useToggle({
    pressed() {
      return pressed.value;
    },
    onUpdatePressed(pressed2) {
      if (pressed2) {
        context.onItemActivate(toValue(props.value));
      } else {
        context.onItemDeactivate(toValue(props.value));
      }
    },
    disabled() {
      return disabled.value;
    }
  });
  const rovingFocusGroupItem = context.rovingFocus ? useRovingFocusGroupItem({
    focusable() {
      return !disabled.value;
    },
    active() {
      return pressed.value;
    }
  }) : void 0;
  return {
    attrs(extraAttrs = []) {
      const attrs = context.type === "multiple" ? {} : {
        "role": "radio",
        "aria-checked": pressed.value,
        "aria-pressed": void 0
      };
      const extraAttrsList = [toggle.attrs()];
      if (rovingFocusGroupItem) {
        extraAttrsList.push(rovingFocusGroupItem.attrs());
      }
      if (extraAttrs && extraAttrs.length > 0) {
        extraAttrsList.push(...extraAttrs);
      }
      if (extraAttrsList.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrsList);
      }
      return attrs;
    }
  };
}

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ToggleGroupItem",
    inheritAttrs: false
  },
  __name: "ToggleGroupItem",
  props: /* @__PURE__ */ mergeDefaults({
    value: {},
    as: {},
    disabled: { type: Boolean }
  }, DEFAULT_TOGGLE_GROUP_ITEM_PROPS),
  setup(__props) {
    const props = __props;
    const toggleGroupItem = useToggleGroupItem(convertPropsToHookProps(
      props,
      ["value", "disabled"]
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(toggleGroupItem).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "ToggleGroup",
    inheritAttrs: false
  },
  __name: "ToggleGroupRoot",
  props: /* @__PURE__ */ mergeDefaults({
    type: {},
    value: {},
    defaultValue: {},
    disabled: { type: Boolean },
    rovingFocus: { type: Boolean },
    loop: { type: Boolean },
    orientation: {},
    dir: {}
  }, DEFAULT_TOGGLE_GROUP_PROPS),
  emits: ["update:value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const toggleGroup = useToggleGroup(convertPropsToHookProps(
      props,
      ["value", "disabled", "dir"],
      () => ({
        onUpdateValue(value) {
          emit("update:value", value);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(toggleGroup).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_TOGGLE_GROUP_ITEM_PROPS as D, _sfc_main$1 as _, useToggleGroupItem as a, DEFAULT_TOGGLE_GROUP_PROPS as b, useToggleGroupContext as c, _sfc_main as d, provideToggleGroupContext as p, useToggleGroup as u };
//# sourceMappingURL=toggle-group.mjs.map
