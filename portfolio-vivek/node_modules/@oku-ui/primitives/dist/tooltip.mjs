import { shallowRef, onBeforeUnmount, useId, watchEffect, onWatcherCleanup, onMounted, defineComponent, openBlock, createElementBlock, normalizeProps, guardReactiveProps, unref, createVNode, withCtx, renderSlot, mergeDefaults, createBlock, createCommentVNode, createTextVNode, toDisplayString } from 'vue';
import { a as usePooperRoot, u as usePopperContext, b as usePopperContent } from './popper.mjs';
import { u as usePresence } from './presence.mjs';
import { i as isPointInPolygon, c as convertPropsToHookProps, n as normalizeAttrs, m as mergePrimitiveAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { i as isClient, t as tryOnScopeDispose } from './avatar.mjs';
import { c as createContext, a as useRef, u as useControllableStateV2 } from './hooks.mjs';
import { u as useDismissableLayer } from './dismissable-layer.mjs';
import { _ as _sfc_main$6 } from './visually-hidden.mjs';

const DEFAULT_TOOLTIP_PROVIDER_PROPS = {
  disableHoverableContent: void 0
};
const [provideTooltipProviderContext, useTooltipProviderContext] = createContext("Tooltip");
function useTooltipProvider({
  delayDuration = 700,
  skipDelayDuration = 300,
  disableHoverableContent = false
} = {}) {
  const isOpenDelayed = shallowRef(true);
  const isPointerInTransitRef = useRef(false);
  let skipDelayTimerRef = 0;
  if (isClient) {
    tryOnScopeDispose(() => {
      window.clearTimeout(skipDelayTimerRef);
    });
  }
  provideTooltipProviderContext({
    isOpenDelayed,
    delayDuration,
    onOpen() {
      window.clearTimeout(skipDelayTimerRef);
      isOpenDelayed.value = false;
    },
    onClose() {
      window.clearTimeout(skipDelayTimerRef);
      skipDelayTimerRef = window.setTimeout(() => {
        isOpenDelayed.value = true;
      }, skipDelayDuration);
    },
    isPointerInTransitRef,
    onPointerInTransitChange(inTransit) {
      isPointerInTransitRef.value = inTransit;
    },
    disableHoverableContent
  });
}

const DEFAULT_TOOLTIP_ROOT_PROPS = {
  open: void 0,
  defaultOpen: void 0,
  disableHoverableContent: void 0
};
const TOOLTIP_OPEN = "tooltip.open";
const [provideTooltipContext, useTooltipContext] = createContext("Tooltip");
function useTooltipRoot(props) {
  const providerContext = useTooltipProviderContext("Tooltip");
  const {
    defaultOpen = false,
    disableHoverableContent = providerContext.disableHoverableContent,
    delayDuration = providerContext.delayDuration
  } = props;
  const trigger = shallowRef();
  let openTimerRef = 0;
  let wasOpenDelayedRef = false;
  const open = useControllableStateV2(
    props.open,
    (v) => {
      if (v) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      props.onUpdateOpen?.(v);
    },
    defaultOpen
  );
  function handleOpen() {
    window.clearTimeout(openTimerRef);
    openTimerRef = 0;
    wasOpenDelayedRef = false;
    open.value = true;
  }
  function handleClose() {
    window.clearTimeout(openTimerRef);
    openTimerRef = 0;
    open.value = false;
  }
  function handleDelayedOpen() {
    window.clearTimeout(openTimerRef);
    openTimerRef = window.setTimeout(() => {
      wasOpenDelayedRef = true;
      open.value = true;
      openTimerRef = 0;
    }, delayDuration);
  }
  onBeforeUnmount(() => {
    if (openTimerRef)
      window.clearTimeout(openTimerRef);
  });
  provideTooltipContext({
    contentId: useId(),
    open,
    stateAttribute() {
      return open.value ? wasOpenDelayedRef ? "delayed-open" : "instant-open" : "closed";
    },
    trigger,
    onTriggerEnter() {
      if (providerContext.isOpenDelayed.value)
        handleDelayedOpen();
      else handleOpen();
    },
    onTriggerLeave() {
      if (disableHoverableContent) {
        handleClose();
      } else {
        window.clearTimeout(openTimerRef);
        openTimerRef = 0;
      }
    },
    onOpen: handleOpen,
    onClose: handleClose,
    disableHoverableContent
  });
  usePooperRoot({ anchor: trigger });
}

const DEFAULT_TOOLTIP_CONTENT_PROPS = {
  forceMount: void 0
};
function useTooltipContent(props = {}) {
  const context = useTooltipContext("TooltipContent");
  const popperContext = usePopperContext("TooltipContent");
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(popperContext.content, context.open);
  return {
    isPresent
  };
}

function getExitSideFromRect(point, rect) {
  const [x, y] = point;
  const top = Math.abs(rect.top - y);
  const bottom = Math.abs(rect.bottom - y);
  const right = Math.abs(rect.right - x);
  const left = Math.abs(rect.left - x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  const [x, y] = exitPoint;
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        [x - padding, y + padding],
        [x + padding, y + padding]
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        [x - padding, y - padding],
        [x + padding, y - padding]
      );
      break;
    case "left":
      paddedExitPoints.push(
        [x + padding, y - padding],
        [x + padding, y + padding]
      );
      break;
    case "right":
      paddedExitPoints.push(
        [x - padding, y - padding],
        [x - padding, y + padding]
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    [left, top],
    [right, top],
    [right, bottom],
    [left, bottom]
  ];
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    const [a1, b1] = a;
    const [a2, b2] = b;
    if (a1 < a2)
      return -1;
    else if (a1 > a2)
      return 1;
    else if (b1 < b2)
      return -1;
    else if (b1 > b2)
      return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    const [pX, pY] = p;
    while (upperHull.length >= 2) {
      const [qX, qY] = upperHull[upperHull.length - 1];
      const [rX, rY] = upperHull[upperHull.length - 2];
      if ((qX - rX) * (pY - rY) >= (qY - rY) * (pX - rX))
        upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    const [pX, pY] = p;
    while (lowerHull.length >= 2) {
      const [qX, qY] = lowerHull[lowerHull.length - 1];
      const [rX, rY] = lowerHull[lowerHull.length - 2];
      if ((qX - rX) * (pY - rY) >= (qY - rY) * (pX - rX))
        lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0]?.[0] === lowerHull[0]?.[0] && upperHull[0]?.[1] === lowerHull[0]?.[1]) {
    return upperHull;
  }
  return upperHull.concat(lowerHull);
}

function useGraceArea(props) {
  const popperContext = usePopperContext("TooltipContentHoverable");
  const pointerGraceArea = shallowRef();
  function handleRemoveGraceArea() {
    pointerGraceArea.value = void 0;
    props.onPointerInTransitChange?.(false);
  }
  function handleCreateGraceArea(event, hoverTarget) {
    const currentTarget = event.currentTarget;
    const exitPoint = [event.clientX, event.clientY];
    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
    pointerGraceArea.value = graceArea;
    props.onPointerInTransitChange?.(true);
  }
  onBeforeUnmount(() => {
    handleRemoveGraceArea();
  });
  if (isClient) {
    let handleTrackPointerGrace = function(event) {
      const target = event.target;
      const _trigger = popperContext.anchor.value;
      const triggerVal = _trigger?.contextElement ?? _trigger;
      const hasEnteredTarget = triggerVal?.contains(target) || popperContext.content.value?.contains(target);
      if (hasEnteredTarget) {
        handleRemoveGraceArea();
      } else {
        const pointerPosition = [event.clientX, event.clientY];
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea.value);
        if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          props.onClose();
        }
      }
    };
    watchEffect(() => {
      const _trigger = popperContext.anchor.value;
      const triggerVal = _trigger?.contextElement ?? _trigger;
      const contentVal = popperContext.content.value;
      if (!triggerVal || !contentVal)
        return;
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, contentVal);
      const handleContentLeave = (event) => handleCreateGraceArea(event, triggerVal);
      triggerVal.addEventListener("pointerleave", handleTriggerLeave);
      contentVal.addEventListener("pointerleave", handleContentLeave);
      onWatcherCleanup(() => {
        triggerVal.removeEventListener("pointerleave", handleTriggerLeave);
        contentVal.removeEventListener("pointerleave", handleContentLeave);
      });
    });
    watchEffect(() => {
      if (!pointerGraceArea.value)
        return;
      document.addEventListener("pointermove", handleTrackPointerGrace);
      onWatcherCleanup(() => {
        document.removeEventListener("pointermove", handleTrackPointerGrace);
      });
    });
  }
}

const DEFAULT_TOOLTIP_CONTENT_IMPL_PROPS = {
  avoidCollisions: void 0,
  hideWhenDetached: void 0
};
const [provideTooltipContentContext, useTooltipContentContext] = createContext("TooltipContent");
function useTooltipContentImpl(props) {
  const context = useTooltipContext("TooltipContentImpl");
  const popperContext = usePopperContext("TooltipContentImpl");
  if (!context.disableHoverableContent) {
    const providerContext = useTooltipProviderContext("TooltipContentHoverable");
    useGraceArea({
      onPointerInTransitChange: providerContext.onPointerInTransitChange,
      onClose: context.onClose
    });
  }
  function handleScroll(event) {
    const target = event.target;
    if (target?.contains(context.trigger.value ?? null))
      context.onClose();
  }
  onMounted(() => {
    document.addEventListener(TOOLTIP_OPEN, context.onClose);
    window.addEventListener("scroll", handleScroll, { capture: true, passive: true });
  });
  onBeforeUnmount(() => {
    document.removeEventListener(TOOLTIP_OPEN, context.onClose);
    window.removeEventListener("scroll", handleScroll, { capture: true });
  });
  provideTooltipContentContext({
    id: context.contentId,
    ariaLabel: props.ariaLabel
  });
  const dismissableLayer = useDismissableLayer({
    el: popperContext.content,
    disableOutsidePointerEvents() {
      return false;
    },
    onEscapeKeydown: props.onEscapeKeydown,
    onDismiss: context.onClose,
    onFocusOutside(event) {
      event.preventDefault();
    },
    onPointerdownOutside: props.onPointerdownOutside
  });
  const popperContent = usePopperContent({
    ...props,
    side: props.side ?? "top"
  });
  return {
    wrapperAttrs: popperContent.wrapperAttrs,
    attrs(extraAttrs = []) {
      const popperAttrs = {
        "data-state": context.stateAttribute(),
        "style": {
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        }
      };
      return popperContent.attrs([dismissableLayer.attrs(), popperAttrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  ...{
    name: "TooltipContentImpl",
    inheritAttrs: false
  },
  __name: "TooltipContentImpl",
  props: /* @__PURE__ */ mergeDefaults({
    ariaLabel: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    dir: {}
  }, DEFAULT_TOOLTIP_CONTENT_IMPL_PROPS),
  emits: ["escapeKeydown", "pointerdownOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const tooltipContentImpl = useTooltipContentImpl(convertPropsToHookProps(
      props,
      ["collisionBoundary", "dir"],
      () => ({
        onEscapeKeydown(event) {
          emit("escapeKeydown", event);
        },
        onPointerdownOutside(event) {
          emit("pointerdownOutside", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", normalizeProps(guardReactiveProps(unref(tooltipContentImpl).wrapperAttrs())), [
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(tooltipContentImpl).attrs([_ctx.$attrs])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16)
      ], 16);
    };
  }
});

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "TooltipContent"
  },
  __name: "TooltipContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_TOOLTIP_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const context = useTooltipContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(context).isPresent.value ? (openBlock(), createBlock(_sfc_main$5, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "TooltipContentAriaLabel"
  },
  __name: "TooltipContentAriaLabel",
  setup(__props) {
    const context = useTooltipContentContext("TooltipContentAriaLabel");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$6), {
        id: unref(context).id,
        role: "tooltip"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(unref(context).ariaLabel), 1)
        ]),
        _: 1
      }, 8, ["id"]);
    };
  }
});

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "TooltipProvider",
  props: /* @__PURE__ */ mergeDefaults({
    delayDuration: {},
    skipDelayDuration: {},
    disableHoverableContent: { type: Boolean }
  }, DEFAULT_TOOLTIP_PROVIDER_PROPS),
  setup(__props) {
    const props = __props;
    useTooltipProvider(props);
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "TooltipRoot",
    inheritAttrs: false
  },
  __name: "TooltipRoot",
  props: /* @__PURE__ */ mergeDefaults({
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    delayDuration: {},
    disableHoverableContent: { type: Boolean }
  }, DEFAULT_TOOLTIP_ROOT_PROPS),
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useTooltipRoot(convertPropsToHookProps(
      props,
      ["open"],
      () => ({
        onUpdateOpen(open) {
          emit("update:open", open);
        }
      })
    ));
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const DEFAULT_TOOLTIP_TRIGGER_PROPS = {
  as: "button"
};
function useTooltipTrigger() {
  const context = useTooltipContext("TooltipTrigger");
  const providerContext = useTooltipProviderContext("TooltipTrigger");
  function setTemplateRef(v) {
    context.trigger.value = v;
  }
  let isPointerDownRef = false;
  let hasPointerMoveOpenedRef = false;
  function handlePointerUp() {
    isPointerDownRef = false;
  }
  function onPointermove(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.pointerType === "touch")
      return;
    if (hasPointerMoveOpenedRef || providerContext.isPointerInTransitRef.value)
      return;
    context.onTriggerEnter();
    hasPointerMoveOpenedRef = true;
  }
  function onPointerleave(event) {
    if (event.defaultPrevented) {
      return;
    }
    context.onTriggerLeave();
    hasPointerMoveOpenedRef = false;
  }
  function onPointerdown(event) {
    if (event.defaultPrevented) {
      return;
    }
    isPointerDownRef = true;
    document.addEventListener("pointerup", handlePointerUp, { once: true });
  }
  function onFocus(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (!isPointerDownRef)
      context.onOpen();
  }
  function onBlur(event) {
    if (event.defaultPrevented) {
      return;
    }
    context.onClose();
  }
  function onClick(event) {
    if (event.defaultPrevented) {
      return;
    }
    context.onClose();
  }
  return {
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setTemplateRef,
        "data-state": context.stateAttribute(),
        "data-grace-area-trigger": true,
        onPointermove,
        onPointerleave,
        onPointerdown,
        onFocus,
        onBlur,
        onClick
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "TooltipTrigger",
    inheritAttrs: false
  },
  __name: "TooltipTrigger",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    virtualRef: {}
  }, DEFAULT_TOOLTIP_TRIGGER_PROPS),
  setup(__props) {
    const tooltipTrigger = useTooltipTrigger();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(tooltipTrigger).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_TOOLTIP_CONTENT_PROPS as D, TOOLTIP_OPEN as T, _sfc_main$4 as _, _sfc_main$3 as a, DEFAULT_TOOLTIP_CONTENT_IMPL_PROPS as b, useTooltipContentContext as c, useTooltipContentImpl as d, DEFAULT_TOOLTIP_PROVIDER_PROPS as e, provideTooltipProviderContext as f, useTooltipProvider as g, useTooltipProviderContext as h, _sfc_main$2 as i, DEFAULT_TOOLTIP_ROOT_PROPS as j, provideTooltipContext as k, useTooltipContext as l, useTooltipRoot as m, _sfc_main$1 as n, DEFAULT_TOOLTIP_TRIGGER_PROPS as o, provideTooltipContentContext as p, useTooltipTrigger as q, _sfc_main as r, useTooltipContent as u };
//# sourceMappingURL=tooltip.mjs.map
