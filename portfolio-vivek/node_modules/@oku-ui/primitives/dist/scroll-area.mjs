import { shallowRef, defineComponent, openBlock, createBlock, unref, normalizeProps, guardReactiveProps, withCtx, renderSlot, computed, mergeProps, createCommentVNode, mergeDefaults, onMounted, onBeforeUnmount, watch, watchEffect, onWatcherCleanup } from 'vue';
import { m as mergePrimitiveAttrs, n as normalizeAttrs, c as convertPropsToHookProps, b as clamp } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { u as useResizeObserver, b as useDebounceFn, i as isClient } from './avatar.mjs';
import { u as usePresence } from './presence.mjs';
import { c as createContext, g as useStateMachine, a as useRef } from './hooks.mjs';
import { u as useDirection } from './direction.mjs';

const DEFAULT_SCROLL_AREA_PROPS = {};
const [provideScrollAreaContext, useScrollAreaContext] = createContext("ScrollArea");
function useScrollAreaRoot(props) {
  const {
    type = "hover",
    scrollHideDelay = 600
  } = props;
  const el = props.el || shallowRef();
  const setElRef = props.el ? void 0 : (value) => el.value = value;
  const viewport = shallowRef();
  const content = shallowRef();
  const scrollbarX = shallowRef();
  const scrollbarY = shallowRef();
  const cornerWidth = shallowRef(0);
  const cornerHeight = shallowRef(0);
  const scrollbarXEnabled = shallowRef(false);
  const scrollbarYEnabled = shallowRef(false);
  const direction = useDirection(props.dir);
  provideScrollAreaContext({
    type,
    dir: direction,
    scrollHideDelay,
    scrollArea: el,
    viewport,
    content,
    scrollbarX,
    scrollbarXEnabled,
    onScrollbarXEnabledChange(rendered) {
      scrollbarXEnabled.value = rendered;
    },
    scrollbarY,
    scrollbarYEnabled,
    onScrollbarYEnabledChange(rendered) {
      scrollbarYEnabled.value = rendered;
    },
    onCornerWidthChange(width) {
      cornerWidth.value = width;
    },
    onCornerHeightChange(height) {
      cornerHeight.value = height;
    }
  });
  return {
    attrs(extraAttrs) {
      const attrs = {
        elRef: setElRef,
        dir: direction.value,
        style: {
          "position": "relative",
          // Pass corner sizes as CSS vars to reduce re-renders of context consumers
          "--radix-scroll-area-corner-width": `${cornerWidth.value}px`,
          "--radix-scroll-area-corner-height": `${cornerHeight.value}px`
        }
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

function useScrollAreaContent() {
  const context = useScrollAreaContext("ScrollAreaContent");
  function setElRef(templateEl) {
    context.content.value = templateEl;
  }
  return {
    attrs(extraAttrs) {
      const attrs = {
        elRef: setElRef,
        style: "min-width: 100%; display: table"
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$b = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaContent",
    inheritAttrs: false
  },
  __name: "ScrollAreaContent",
  setup(__props) {
    const scrollAreaContent = useScrollAreaContent();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(scrollAreaContent).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

function useScrollAreaCorner() {
  const context = useScrollAreaContext("ScrollAreaCorner");
  const hasCorner = computed(() => context.type !== "scroll" && Boolean(context.scrollbarX.value && context.scrollbarY.value));
  return {
    hasCorner
  };
}

function useScrollAreaCornerImpl() {
  const context = useScrollAreaContext("ScrollAreaCornerImpl");
  const width = shallowRef(0);
  const height = shallowRef(0);
  const hasSize = computed(() => Boolean(width.value && height.value));
  useResizeObserver(context.scrollbarX, () => {
    const _height = context.scrollbarX.value?.offsetHeight || 0;
    context.onCornerHeightChange(_height);
    height.value = _height;
  });
  useResizeObserver(context.scrollbarY, () => {
    const _width = context.scrollbarY.value?.offsetWidth || 0;
    context.onCornerWidthChange(_width);
    width.value = _width;
  });
  return {
    hasSize,
    attrs(extraAttrs) {
      const attrs = {
        style: {
          width: `${width.value}px`,
          height: `${height.value}px`,
          position: "absolute",
          right: context.dir.value === "ltr" ? 0 : void 0,
          left: context.dir.value === "rtl" ? 0 : void 0,
          bottom: 0
        }
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$a = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaCornerImpl",
    inheritAttrs: false
  },
  __name: "ScrollAreaCornerImpl",
  setup(__props) {
    const scrollAreaCornerImpl = useScrollAreaCornerImpl();
    return (_ctx, _cache) => {
      return unref(scrollAreaCornerImpl).hasSize.value ? (openBlock(), createBlock(unref(Primitive), normalizeProps(mergeProps({ key: 0 }, unref(normalizeAttrs)(unref(scrollAreaCornerImpl).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaCorner"
  },
  __name: "ScrollAreaCorner",
  setup(__props) {
    const scrollAreaCorner = useScrollAreaCorner();
    return (_ctx, _cache) => {
      return unref(scrollAreaCorner).hasCorner.value ? (openBlock(), createBlock(_sfc_main$a, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaRoot",
    inheritAttrs: false
  },
  __name: "ScrollAreaRoot",
  props: /* @__PURE__ */ mergeDefaults({
    type: {},
    dir: {},
    scrollHideDelay: {}
  }, DEFAULT_SCROLL_AREA_PROPS),
  setup(__props) {
    const props = __props;
    const scrollAreaRoot = useScrollAreaRoot(convertPropsToHookProps(props, ["dir"]));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(scrollAreaRoot).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const DEFAULT_SCROLLBAR_PROPS = {};
const [provideScrollbarContext, useScrollbarContext] = createContext("ScrollAreaScrollbar");
function useScrollAreaScrollbar(props) {
  const { orientation = "vertical" } = props;
  const isHorizontal = orientation === "horizontal";
  const context = useScrollAreaContext("ScrollAreaScrollbar");
  onMounted(() => {
    if (isHorizontal)
      context.onScrollbarXEnabledChange(true);
    else
      context.onScrollbarYEnabledChange(true);
  });
  onBeforeUnmount(() => {
    if (isHorizontal)
      context.onScrollbarXEnabledChange(false);
    else
      context.onScrollbarYEnabledChange(false);
  });
  return {
    attrs(extraAttrs) {
      const attrs = {
        orientation
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const DEFAULT_SCROLLBAR_AUTO_PROPS = {
  forceMount: void 0
};
function useScrollAreaScrollbarAuto(props) {
  const { orientation = "vertical" } = props;
  const isHorizontal = orientation === "horizontal";
  const context = useScrollAreaContext("ScrollAreaScrollbarAuto");
  const visible = shallowRef(false);
  const scrollbar = isHorizontal ? context.scrollbarX : context.scrollbarY;
  const handleResize = useDebounceFn(() => {
    const viewport = context.viewport.value;
    if (viewport) {
      const isOverflowX = viewport.offsetWidth < viewport.scrollWidth;
      const isOverflowY = viewport.offsetHeight < viewport.scrollHeight;
      visible.value = orientation === "horizontal" ? isOverflowX : isOverflowY;
    }
  }, 10);
  useResizeObserver(context.viewport, handleResize);
  useResizeObserver(context.content, handleResize);
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(scrollbar, visible);
  return {
    isPresent,
    attrs(extraAttrs) {
      const attrs = {
        "data-state": visible.value ? "visible" : "hidden",
        "orientation": orientation
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

function toInt(value) {
  return value ? Number.parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset;
  const minPointerPos = sizes.scrollbar.paddingStart + offset;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange[0], scrollClampRange[1]);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function addUnlinkedScrollListener(node, handler = () => {
}) {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll)
      handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
}

const DEFAULT_SCROLL_AREA_SCROLLBAR_VISIBLE_PROPS = {};
let wheelListeners = [];
function onDocumentWheel(event) {
  for (const wheelListener of wheelListeners) {
    wheelListener(event);
  }
}
function useScrollAreaScrollbarVisible(props) {
  const isHorizontal = props.orientation === "horizontal";
  const context = useScrollAreaContext("ScrollAreaScrollbarVisible");
  const scrollbar = isHorizontal ? context.scrollbarX : context.scrollbarY;
  function setElRef(templateEl) {
    scrollbar.value = templateEl;
  }
  const thumbRef = shallowRef();
  let pointerOffset = 0;
  const sizes = shallowRef({
    content: 0,
    viewport: 0,
    scrollbar: {
      size: 0,
      paddingStart: 0,
      paddingEnd: 0
    }
  });
  const hasThumb = computed(() => {
    const thumbRatio = getThumbRatio(sizes.value.viewport, sizes.value.content);
    return Boolean(thumbRatio > 0 && thumbRatio < 1);
  });
  let rect;
  let prevWebkitUserSelect = "";
  function handleDragScroll(event) {
    if (!rect)
      return;
    const viewport = context.viewport.value;
    if (!viewport)
      return;
    if (isHorizontal) {
      viewport.scrollLeft = getScrollPositionFromPointer(
        event.clientX - rect.left,
        pointerOffset,
        sizes.value,
        context.dir.value
      );
    } else {
      viewport.scrollTop = getScrollPositionFromPointer(
        event.clientY - rect.top,
        pointerOffset,
        sizes.value
      );
    }
  }
  function onPointerdown(event) {
    if (event.defaultPrevented)
      return;
    const mainPointer = 0;
    if (event.button !== mainPointer)
      return;
    const element = event.target;
    element.setPointerCapture(event.pointerId);
    rect = scrollbar.value.getBoundingClientRect();
    prevWebkitUserSelect = document.body.style.webkitUserSelect;
    document.body.style.webkitUserSelect = "none";
    if (context.viewport)
      context.viewport.value.style.scrollBehavior = "auto";
    handleDragScroll(event);
  }
  function onPointermove(event) {
    if (event.defaultPrevented)
      return;
    handleDragScroll(event);
  }
  function onPointerup(event) {
    if (event.defaultPrevented)
      return;
    const element = event.target;
    if (element.hasPointerCapture(event.pointerId))
      element.releasePointerCapture(event.pointerId);
    document.body.style.webkitUserSelect = prevWebkitUserSelect;
    if (context.viewport)
      context.viewport.value.style.scrollBehavior = "";
    rect = void 0;
  }
  function onImplWheelScroll(event) {
    const isScrollbarWheel = scrollbar.value?.contains(event.target);
    if (!isScrollbarWheel)
      return;
    const viewport = context.viewport.value;
    if (!viewport)
      return;
    const maxScrollPos = sizes.value.content - sizes.value.viewport;
    if (isHorizontal) {
      const scrollPos = viewport.scrollLeft + event.deltaY;
      viewport.scrollLeft = scrollPos;
      if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos))
        event.preventDefault();
    } else {
      const scrollPos = viewport.scrollTop + event.deltaY;
      viewport.scrollTop = scrollPos;
      if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos))
        event.preventDefault();
    }
  }
  onMounted(() => {
    if (wheelListeners.length === 0)
      document.addEventListener("wheel", onDocumentWheel, { passive: false });
    wheelListeners.push(onImplWheelScroll);
  });
  onBeforeUnmount(() => {
    wheelListeners = wheelListeners.filter((i) => i !== onImplWheelScroll);
    if (wheelListeners.length === 0)
      document.removeEventListener("wheel", onDocumentWheel);
  });
  watch(sizes, onThumbPositionChange);
  function onThumbPositionChange() {
    const viewport = context.viewport.value;
    const thumb = thumbRef.value;
    if (!viewport || !thumb)
      return;
    if (isHorizontal)
      thumb.style.transform = `translate3d(${getThumbOffsetFromScroll(viewport.scrollLeft, sizes.value, context.dir.value)}px, 0, 0)`;
    else
      thumb.style.transform = `translate3d(0, ${getThumbOffsetFromScroll(viewport.scrollTop, sizes.value)}px, 0)`;
  }
  function onResize() {
    const viewportEl = context.viewport.value;
    const scrollbarEl = scrollbar.value;
    if (!scrollbarEl || !viewportEl)
      return;
    if (isHorizontal) {
      sizes.value = {
        content: viewportEl.scrollWidth ?? 0,
        viewport: viewportEl.offsetWidth ?? 0,
        scrollbar: {
          size: scrollbarEl.clientWidth ?? 0,
          paddingStart: toInt(getComputedStyle(scrollbarEl).paddingLeft),
          paddingEnd: toInt(getComputedStyle(scrollbarEl).paddingRight)
        }
      };
    } else {
      sizes.value = {
        content: viewportEl.scrollHeight ?? 0,
        viewport: viewportEl.offsetHeight ?? 0,
        scrollbar: {
          size: scrollbarEl.clientHeight ?? 0,
          paddingStart: toInt(getComputedStyle(scrollbarEl).paddingLeft),
          paddingEnd: toInt(getComputedStyle(scrollbarEl).paddingRight)
        }
      };
    }
  }
  const handleResize = useDebounceFn(onResize, 10);
  useResizeObserver([context.scrollbarX, context.scrollbarY], handleResize);
  useResizeObserver(context.content, handleResize);
  provideScrollbarContext({
    hasThumb,
    thumb: thumbRef,
    onThumbPointerUp() {
      pointerOffset = 0;
    },
    onThumbPositionChange,
    onThumbPointerDown(payload) {
      if (isHorizontal)
        pointerOffset = payload.x;
      else
        pointerOffset = payload.y;
    }
  });
  return {
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "style": isHorizontal ? {
          "position": "absolute",
          "bottom": 0,
          "left": context.dir.value === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
          "right": context.dir.value === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
          "--radix-scroll-area-thumb-width": `${getThumbSize(sizes.value)}px`
        } : {
          "position": "absolute",
          "top": 0,
          "right": context.dir.value === "ltr" ? 0 : void 0,
          "left": context.dir.value === "rtl" ? 0 : void 0,
          "bottom": "var(--radix-scroll-area-corner-height)",
          "--radix-scroll-area-thumb-height": `${getThumbSize(sizes.value)}px`
        },
        "data-orientation": isHorizontal ? "horizontal" : "vertical",
        onPointerdown,
        onPointermove,
        onPointerup
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaScrollbarVisible",
    inheritAttrs: false
  },
  __name: "ScrollAreaScrollbarVisible",
  props: /* @__PURE__ */ mergeDefaults({
    orientation: {}
  }, DEFAULT_SCROLL_AREA_SCROLLBAR_VISIBLE_PROPS),
  setup(__props) {
    const props = __props;
    const scrollAreaScrollbarVisible = useScrollAreaScrollbarVisible(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(scrollAreaScrollbarVisible).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaScrollbarAuto",
    inheritAttrs: false
  },
  __name: "ScrollAreaScrollbarAuto",
  props: /* @__PURE__ */ mergeDefaults({
    orientation: {},
    forceMount: { type: Boolean }
  }, DEFAULT_SCROLLBAR_AUTO_PROPS),
  setup(__props) {
    const props = __props;
    const scrollAreaScrollbarAuto = useScrollAreaScrollbarAuto(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(scrollAreaScrollbarAuto).isPresent.value ? (openBlock(), createBlock(_sfc_main$7, normalizeProps(mergeProps({ key: 0 }, unref(normalizeAttrs)(unref(scrollAreaScrollbarAuto).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode("", true);
    };
  }
});

const DEFAULT_SCROLLBAR_HOVER_PROPS = {
  forceMount: void 0
};
function useScrollAreaScrollbarHover(props) {
  const { orientation = "vertical" } = props;
  const isHorizontal = orientation === "horizontal";
  const context = useScrollAreaContext("ScrollAreaScrollbarHover");
  const visible = shallowRef(false);
  const scrollbar = isHorizontal ? context.scrollbarX : context.scrollbarY;
  watchEffect(() => {
    const scrollArea = context.scrollArea.value;
    if (!scrollArea)
      return;
    let hideTimer = 0;
    const handlePointerEnter = () => {
      window.clearTimeout(hideTimer);
      visible.value = true;
    };
    const handlePointerLeave = () => {
      hideTimer = window.setTimeout(() => {
        visible.value = false;
      }, context.scrollHideDelay);
    };
    scrollArea.addEventListener("pointerenter", handlePointerEnter);
    scrollArea.addEventListener("pointerleave", handlePointerLeave);
    onWatcherCleanup(() => {
      window.clearTimeout(hideTimer);
      scrollArea.removeEventListener("pointerenter", handlePointerEnter);
      scrollArea.removeEventListener("pointerleave", handlePointerLeave);
    });
  });
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(scrollbar, visible);
  return {
    isPresent,
    attrs(extraAttrs) {
      const attrs = {
        "data-state": visible.value ? "visible" : "hidden",
        "orientation": orientation
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaScrollbarHover",
    inheritAttrs: false
  },
  __name: "ScrollAreaScrollbarHover",
  props: /* @__PURE__ */ mergeDefaults({
    orientation: {},
    forceMount: { type: Boolean }
  }, DEFAULT_SCROLLBAR_HOVER_PROPS),
  setup(__props) {
    const props = __props;
    const scrollAreaScrollbarHover = useScrollAreaScrollbarHover(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(scrollAreaScrollbarHover).isPresent.value ? (openBlock(), createBlock(_sfc_main$6, normalizeProps(mergeProps({ key: 0 }, unref(normalizeAttrs)(unref(scrollAreaScrollbarHover).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode("", true);
    };
  }
});

const DEFAULT_SCROLLBAR_SCROLL_PROPS = {
  forceMount: void 0
};
function useScrollAreaScrollbarScroll(props) {
  const { orientation = "vertical" } = props;
  const isHorizontal = orientation === "horizontal";
  const context = useScrollAreaContext("ScrollAreaScrollbarScroll");
  const scrollbar = isHorizontal ? context.scrollbarX : context.scrollbarY;
  const [state, send] = useStateMachine("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  const debounceScrollEnd = useDebounceFn(() => send("SCROLL_END"), 100);
  if (isClient) {
    watchEffect(() => {
      if (state.value !== "idle")
        return;
      const timeId = window.setTimeout(
        () => send("HIDE"),
        context.scrollHideDelay
      );
      onWatcherCleanup(() => {
        window.clearTimeout(timeId);
      });
    });
  }
  watchEffect(() => {
    const viewport = context.viewport.value;
    if (!viewport)
      return;
    const scrollDirection = orientation === "horizontal" ? "scrollLeft" : "scrollTop";
    let prevScrollPos = viewport[scrollDirection];
    const handleScroll = () => {
      const scrollPos = viewport[scrollDirection];
      const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
      if (hasScrollInDirectionChanged) {
        send("SCROLL");
        debounceScrollEnd();
      }
      prevScrollPos = scrollPos;
    };
    viewport.addEventListener("scroll", handleScroll);
    onWatcherCleanup(() => {
      viewport.removeEventListener("scroll", handleScroll);
    });
  });
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(scrollbar, () => state.value !== "hidden");
  function onPointerenter(event) {
    if (event.defaultPrevented)
      return;
    send("POINTER_ENTER");
  }
  function onPointerleave(event) {
    if (event.defaultPrevented)
      return;
    send("POINTER_LEAVE");
  }
  return {
    isPresent,
    attrs(extraAttrs) {
      const attrs = {
        "data-state": state.value === "hidden" ? "hidden" : "visible",
        "orientation": orientation,
        onPointerenter,
        onPointerleave
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaScrollbarScroll",
    inheritAttrs: false
  },
  __name: "ScrollAreaScrollbarScroll",
  props: /* @__PURE__ */ mergeDefaults({
    orientation: {},
    forceMount: { type: Boolean }
  }, DEFAULT_SCROLLBAR_SCROLL_PROPS),
  setup(__props) {
    const props = __props;
    const scrollAreaScrollbarScroll = useScrollAreaScrollbarScroll(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(scrollAreaScrollbarScroll).isPresent.value ? (openBlock(), createBlock(_sfc_main$7, normalizeProps(mergeProps({ key: 0 }, unref(normalizeAttrs)(unref(scrollAreaScrollbarScroll).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaScrollbar",
    inheritAttrs: false
  },
  __name: "ScrollAreaScrollbar",
  props: /* @__PURE__ */ mergeDefaults({
    orientation: {}
  }, DEFAULT_SCROLLBAR_PROPS),
  setup(__props) {
    const props = __props;
    const context = useScrollAreaContext("ScrollAreaScrollbar");
    const scrollAreaScrollbar = useScrollAreaScrollbar(convertPropsToHookProps(props));
    const Comp = context.type === "hover" ? _sfc_main$5 : context.type === "scroll" ? _sfc_main$4 : context.type === "auto" ? _sfc_main$6 : _sfc_main$7;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Comp), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(scrollAreaScrollbar).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const DEFAULT_SCROLL_AREA_THUMB_PROPS = {
  forceMount: void 0
};
function useScrollAreaThumb(props) {
  const scrollbarContext = useScrollbarContext("ScrollAreaThumb");
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(scrollbarContext.thumb, scrollbarContext.hasThumb);
  return {
    isPresent
  };
}

function useScrollAreaThumbImpl() {
  const scrollAreaContext = useScrollAreaContext("ScrollAreaThumb");
  const scrollbarContext = useScrollbarContext("ScrollAreaThumb");
  function setElRef(templateEl) {
    scrollbarContext.thumb.value = templateEl;
  }
  let removeUnlinkedScrollListener;
  const debounceScrollEnd = useDebounceFn(() => {
    if (!removeUnlinkedScrollListener)
      return;
    removeUnlinkedScrollListener();
    removeUnlinkedScrollListener = void 0;
  }, 100);
  watchEffect(() => {
    const viewport = scrollAreaContext.viewport.value;
    if (!viewport)
      return;
    function handleScroll() {
      debounceScrollEnd();
      if (!removeUnlinkedScrollListener) {
        const listener = addUnlinkedScrollListener(viewport, scrollbarContext.onThumbPositionChange);
        removeUnlinkedScrollListener = listener;
        scrollbarContext.onThumbPositionChange();
      }
    }
    scrollbarContext.onThumbPositionChange();
    viewport.addEventListener("scroll", handleScroll);
    onWatcherCleanup(() => {
      viewport.removeEventListener("scroll", handleScroll);
    });
  });
  function onPointerdownCapture(event) {
    if (event.defaultPrevented)
      return;
    const thumb = event.target;
    const thumbRect = thumb.getBoundingClientRect();
    const x = event.clientX - thumbRect.left;
    const y = event.clientY - thumbRect.top;
    scrollbarContext.onThumbPointerDown({ x, y });
  }
  function onPointerup(event) {
    if (event.defaultPrevented)
      return;
    scrollbarContext.onThumbPointerUp();
  }
  return {
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "data-state": scrollbarContext.hasThumb.value ? "visible" : "hidden",
        "style": "width: var(--radix-scroll-area-thumb-width); height: var(--radix-scroll-area-thumb-height)",
        onPointerdownCapture,
        onPointerup
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaThumbImpl",
    inheritAttrs: false
  },
  __name: "ScrollAreaThumbImpl",
  setup(__props) {
    const scrollAreaThumbImpl = useScrollAreaThumbImpl();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(scrollAreaThumbImpl).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaThumb"
  },
  __name: "ScrollAreaThumb",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_SCROLL_AREA_THUMB_PROPS),
  setup(__props) {
    const props = __props;
    const scrollAreaThumb = useScrollAreaThumb(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(scrollAreaThumb).isPresent.value ? (openBlock(), createBlock(_sfc_main$2, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

function useScrollAreaViewport(props = {}) {
  const context = useScrollAreaContext("ScrollAreaViewport");
  const el = props.el || useRef();
  const setElRef = props.el ? void 0 : (value) => el.value = value;
  onMounted(() => {
    context.viewport.value = el.value;
  });
  return {
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "data-radix-scroll-area-viewport": "",
        "style": {
          /**
           * We don't support `visible` because the intention is to have at least one scrollbar
           * if this component is used and `visible` will behave like `auto` in that case
           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
           *
           * We don't handle `auto` because the intention is for the native implementation
           * to be hidden if using this component. We just want to ensure the node is scrollable
           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
           * the browser from having to work out whether to render native scrollbars or not,
           * we tell it to with the intention of hiding them in CSS.
           */
          overflowX: context.scrollbarXEnabled.value ? "scroll" : "hidden",
          overflowY: context.scrollbarYEnabled.value ? "scroll" : "hidden"
        }
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "ScrollAreaViewport",
    inheritAttrs: false
  },
  __name: "ScrollAreaViewport",
  setup(__props) {
    const scrollAreaViewport = useScrollAreaViewport();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(scrollAreaViewport).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_SCROLL_AREA_PROPS as D, _sfc_main$b as _, useScrollAreaCorner as a, _sfc_main$9 as b, useScrollAreaCornerImpl as c, useScrollAreaContext as d, useScrollAreaRoot as e, _sfc_main$8 as f, DEFAULT_SCROLLBAR_PROPS as g, provideScrollbarContext as h, useScrollbarContext as i, _sfc_main$3 as j, DEFAULT_SCROLLBAR_AUTO_PROPS as k, useScrollAreaScrollbarAuto as l, DEFAULT_SCROLLBAR_HOVER_PROPS as m, useScrollAreaScrollbarHover as n, DEFAULT_SCROLLBAR_SCROLL_PROPS as o, provideScrollAreaContext as p, useScrollAreaScrollbarScroll as q, DEFAULT_SCROLL_AREA_SCROLLBAR_VISIBLE_PROPS as r, useScrollAreaScrollbarVisible as s, DEFAULT_SCROLL_AREA_THUMB_PROPS as t, useScrollAreaContent as u, useScrollAreaThumb as v, _sfc_main$1 as w, useScrollAreaThumbImpl as x, useScrollAreaViewport as y, _sfc_main as z };
//# sourceMappingURL=scroll-area.mjs.map
