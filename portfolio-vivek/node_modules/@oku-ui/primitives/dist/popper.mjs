import { shallowRef, watchEffect, watch, toValue, defineComponent, openBlock, createElementBlock, normalizeStyle, unref, createVNode, mergeProps, withCtx, renderSlot, createElementVNode, mergeDefaults } from 'vue';
import { c as createContext, f as useSize } from './hooks.mjs';
import { u as useFloating, a as arrow } from './floating.mjs';
import { m as mergePrimitiveAttrs } from './shared.mjs';
import { offset, shift, limitShift, flip, size, hide, autoUpdate } from '@floating-ui/dom';
import { P as Primitive } from './primitive.mjs';

function hasWindow() {
  return typeof window !== 'undefined';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}

const [providePopperContext, usePopperContext] = createContext("Popper");
function usePooperRoot(props) {
  const content = props?.content ?? shallowRef();
  const anchor = props?.anchor ?? shallowRef();
  let anchorRef;
  providePopperContext({
    content,
    anchor,
    onAnchorChange(node) {
      if (props?.anchor != null)
        return;
      if (isElement(anchorRef) || anchorRef == null || node != null && !isElement(node)) {
        anchor.value = node;
        anchorRef = node;
      }
    },
    onPostionAnchorChange(node) {
      if (props?.anchor != null)
        return;
      const computedPositionReference = isElement(node) ? {
        getBoundingClientRect: () => node.getBoundingClientRect(),
        contextElement: node
      } : node;
      anchor.value = computedPositionReference;
      anchorRef = computedPositionReference;
    }
  });
}

const DEFAULT_ARROW_PROPS = {
  as: "svg",
  width: 10,
  height: 5
};
const OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};

function isNotNull(value) {
  return value != null;
}
function transformOrigin(options) {
  return {
    name: "transformOrigin",
    options,
    fn(data) {
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
      const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
      let x = "";
      let y = "";
      if (placedSide === "bottom") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x, y } };
    }
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}

const [provideContentContext, useContentContext] = createContext("PopperContent");
function usePopperContent(props = {}) {
  const {
    side = "bottom",
    sideOffset = 0,
    align = "center",
    alignOffset = 0,
    arrowPadding = 0,
    avoidCollisions = true,
    collisionBoundary = () => [],
    collisionPadding: propCollisionPadding = 0,
    sticky = "partial",
    hideWhenDetached = false,
    updatePositionStrategy = "optimized"
  } = props;
  const context = usePopperContext("PopperContent");
  function setTemplateContent(value) {
    context.content.value = value;
  }
  const floatingEl = shallowRef();
  function setTemplateFloating(value) {
    floatingEl.value = value;
  }
  const arrow$1 = shallowRef();
  const arrowSize = useSize(arrow$1);
  function getDetectOverflowOptions() {
    const collisionPadding = typeof propCollisionPadding === "number" ? propCollisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...propCollisionPadding };
    const _collisionBoundary = collisionBoundary();
    const boundary = Array.isArray(_collisionBoundary) ? _collisionBoundary : [_collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    return {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
  }
  function floatingConfig() {
    const detectOverflowOptions = getDetectOverflowOptions();
    const placement2 = side + (align !== "center" ? `-${align}` : "");
    const arrowHeight = arrowSize.value?.height || 0;
    const arrowWidth = arrowSize.value?.width || 0;
    const middleware = [
      offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset })
    ];
    if (avoidCollisions) {
      middleware.push(
        shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        flip(detectOverflowOptions)
      );
    }
    middleware.push(size({
      ...detectOverflowOptions,
      apply: (state) => {
        const { width: anchorWidth, height: anchorHeight } = state.rects.reference;
        const contentStyle = state.elements.floating.style;
        contentStyle.setProperty("--radix-popper-available-width", `${state.availableWidth}px`);
        contentStyle.setProperty("--radix-popper-available-height", `${state.availableHeight}px`);
        contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
        contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
      }
    }));
    if (arrow$1.value) {
      middleware.push(arrow({ element: arrow$1, padding: arrowPadding }));
    }
    middleware.push(transformOrigin({ arrowWidth, arrowHeight }));
    if (hideWhenDetached) {
      middleware.push(hide({ strategy: "referenceHidden", ...detectOverflowOptions }));
    }
    return {
      strategy: "fixed",
      placement: placement2,
      middleware
    };
  }
  const { floatingStyles, placement, isPositioned, middlewareData } = useFloating(
    {
      elements: {
        floatingEl,
        referenceEl: context.anchor
      },
      whileElementsMounted(reference, floating, update) {
        return autoUpdate(reference, floating, update, {
          animationFrame: updatePositionStrategy === "always"
        });
      }
    },
    floatingConfig
  );
  const placedSide = shallowRef("bottom");
  const placedAlign = shallowRef("center");
  watchEffect(() => {
    const [side2, align2] = getSideAndAlignFromPlacement(placement.value);
    placedSide.value = side2;
    placedAlign.value = align2;
  });
  watchEffect(() => {
    if (isPositioned.value) {
      props.onPlaced?.();
    }
  }, { flush: "post" });
  const contentZIndex = shallowRef("");
  watch(context.content, (contentVal) => {
    if (contentVal) {
      contentZIndex.value = window.getComputedStyle(contentVal).zIndex;
    }
  });
  provideContentContext({
    placedSide,
    onArrowChange(newArrow) {
      arrow$1.value = newArrow;
    },
    arrowX() {
      return middlewareData.value.arrow?.x ?? void 0;
    },
    arrowY() {
      return middlewareData.value.arrow?.y ?? void 0;
    },
    shouldHideArrow() {
      return middlewareData.value.arrow?.centerOffset !== 0;
    }
  });
  return {
    wrapperAttrs() {
      const _middlewareData = middlewareData.value;
      const _floatingStyles = floatingStyles.value;
      const attrs = {
        "ref": setTemplateFloating,
        "data-radix-popper-content-wrapper": "",
        "style": {
          ..._floatingStyles,
          "transform": isPositioned.value ? _floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          "minWidth": "max-content",
          "zIndex": contentZIndex.value,
          "--radix-popper-transform-origin": [
            _middlewareData.transformOrigin?.x,
            _middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ..._middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        "dir": toValue(props.dir)
      };
      return attrs;
    },
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setTemplateContent,
        "data-side": placedSide.value,
        "data-align": placedAlign.value,
        "style": {
          // if the PopperContent hasn't been placed yet (not all measurements done)
          // we prevent animations so that users's animation don't kick in too early referring wrong sides
          animation: !isPositioned.value ? "none" : void 0
        }
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "PopperArrow",
    inheritAttrs: false
  },
  __name: "PopperArrow",
  props: /* @__PURE__ */ mergeDefaults({
    width: {},
    height: {},
    as: {}
  }, DEFAULT_ARROW_PROPS),
  setup(__props) {
    const contentContext = useContentContext("PopperArrow");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        ref: unref(contentContext).onArrowChange,
        style: normalizeStyle({
          position: "absolute",
          left: unref(contentContext).arrowX() ? `${unref(contentContext).arrowX()}px` : void 0,
          top: unref(contentContext).arrowY() ? `${unref(contentContext).arrowY()}px` : void 0,
          [unref(OPPOSITE_SIDE)[unref(contentContext).placedSide.value]]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[unref(contentContext).placedSide.value],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[unref(contentContext).placedSide.value],
          visibility: unref(contentContext).shouldHideArrow() ? "hidden" : void 0
        })
      }, [
        createVNode(unref(Primitive), mergeProps({ as: _ctx.as }, _ctx.$attrs, {
          width: _ctx.width,
          height: _ctx.height,
          viewBox: _ctx.as === "template" ? void 0 : "0 0 30 10",
          preserveAspectRatio: _ctx.as === "template" ? void 0 : "none",
          style: { "display": "block" }
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", {}, () => [
              _cache[0] || (_cache[0] = createElementVNode("polygon", { points: "0,0 30,0 15,10" }, null, -1))
            ])
          ]),
          _: 3
        }, 16, ["as", "width", "height", "viewBox", "preserveAspectRatio"])
      ], 4);
    };
  }
});

export { _sfc_main as _, usePooperRoot as a, usePopperContent as b, usePopperContext as u };
//# sourceMappingURL=popper.mjs.map
