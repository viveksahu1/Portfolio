import { shallowRef, useId, computed, watch, defineComponent, openBlock, createElementBlock, normalizeProps, guardReactiveProps, unref, createVNode, withCtx, renderSlot, mergeDefaults, createBlock, createCommentVNode, watchEffect, onMounted } from 'vue';
import { f as useMenuContent, a as useMenuRoot, b as useMenuContentImpl, c as useMenuSub, d as useMenuSubContent, e as useMenuSubContentImpl, g as useMenuSubTrigger } from './menu.mjs';
import { w as wrapArray, c as convertPropsToHookProps, n as normalizeAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, u as useControllableStateV2, a as useRef } from './hooks.mjs';
import { c as createCollection, D as DATA_COLLECTION_ITEM } from './collection.mjs';
import { u as useDirection } from './direction.mjs';
import { u as useRovingFocusGroupRoot, a as useRovingFocusGroupItem } from './roving-focus.mjs';
import { u as usePopperContext } from './popper.mjs';

const DEFAULT_MENUBAR_CONTENT_PROPS = {
  forceMount: void 0
};
const useMenubarContent = useMenuContent;

const DEFAULT_MENUBAR_ROOT_PROPS = {
  value: void 0,
  loop: void 0
};
const [provideMenubarContext, useMenubarContext] = createContext("Menubar");
const [Collection, useCollection] = createCollection("Menubar");
function useMenuvarRoot(props = {}) {
  const { loop = true, defaultValue = "" } = props;
  const direction = useDirection(props.dir);
  const value = useControllableStateV2(props.value, props.onUpdateValue, defaultValue);
  const currentTabStopId = shallowRef();
  provideMenubarContext({
    value,
    onMenuOpen(id) {
      value.value = id;
      currentTabStopId.value = id;
    },
    onMenuClose() {
      value.value = "";
    },
    onMenuToggle(id) {
      value.value = value.value ? "" : id;
      currentTabStopId.value = id;
    },
    dir: direction,
    loop
  });
  const elRef = useRef();
  Collection.provideCollectionContext(elRef);
  function setElRef(el) {
    elRef.value = el;
  }
  const rovingFocusGroupRoot = useRovingFocusGroupRoot({
    elRef,
    orientation: "horizontal",
    loop,
    dir: direction,
    currentTabStopId() {
      return currentTabStopId.value;
    },
    onUpdateCurrentTabStopId(tabStopId) {
      currentTabStopId.value = tabStopId;
    }
  });
  const rovingFocusGroupRootAttrs = {
    elRef: setElRef,
    role: "menubar"
  };
  return {
    attrs(extraAttrs = []) {
      return rovingFocusGroupRoot.attrs([rovingFocusGroupRootAttrs, ...extraAttrs]);
    }
  };
}

const [provideMenubarMenuContext, useMenubarMenuContext] = createContext("MenubarMenu");
function useMenubarMenu(props) {
  const value = props.value || useId();
  const context = useMenubarContext("MenubarMenu");
  const triggerRef = useRef();
  const wasKeyboardTriggerOpenRef = useRef(false);
  const open = computed(() => context.value.value === value);
  watch(open, (v) => {
    if (!v)
      wasKeyboardTriggerOpenRef.value = false;
  });
  provideMenubarMenuContext({
    value,
    triggerId: useId(),
    triggerRef,
    contentId: useId(),
    wasKeyboardTriggerOpenRef
  });
  useMenuRoot({
    open() {
      return open.value;
    },
    onUpdateOpen(v) {
      if (!v)
        context.onMenuClose();
    },
    dir() {
      return context.dir.value;
    },
    modal: false
  });
}

const DEFAULT_MENUBAR_CONTENT_IMPL_PROPS = {
  avoidCollisions: void 0,
  hideWhenDetached: void 0,
  loop: void 0
};
function useMenubarContentImpl(props = {}) {
  const { align = "start" } = props;
  const context = useMenubarContext("MenubarContent");
  const menuContext = useMenubarMenuContext("MenubarContent");
  const getItems = useCollection();
  let hasInteractedOutsideRef = false;
  function onKeydown(event) {
    if (!["ArrowRight", "ArrowLeft"].includes(event.key))
      return;
    const target = event.target;
    const targetIsSubTrigger = target.hasAttribute("data-radix-menubar-subtrigger");
    const isKeyDownInsideSubMenu = target.closest("[data-radix-menubar-content]") !== event.currentTarget;
    const prevMenuKey = context.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft";
    const isPrevKey = prevMenuKey === event.key;
    const isNextKey = !isPrevKey;
    if (isNextKey && targetIsSubTrigger)
      return;
    if (isKeyDownInsideSubMenu && isPrevKey)
      return;
    let candidateValues = [];
    for (const item of getItems()) {
      if (item.$$rcid.$menubar.disabled)
        continue;
      candidateValues.push(item.$$rcid.$menubar.value);
    }
    if (isPrevKey)
      candidateValues.reverse();
    const currentIndex = candidateValues.indexOf(menuContext.value);
    candidateValues = context.loop ? wrapArray(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
    const [nextValue] = candidateValues;
    if (nextValue)
      context.onMenuOpen(nextValue);
  }
  const menuContentImpl = useMenuContentImpl({
    ...props,
    align,
    onCloseAutoFocus(event) {
      props.onCloseAutoFocus?.(event);
      if (event.defaultPrevented)
        return;
      const menubarOpen = Boolean(context.value.value);
      if (!menubarOpen && !hasInteractedOutsideRef) {
        menuContext.triggerRef.value?.focus();
      }
      hasInteractedOutsideRef = false;
      event.preventDefault();
    },
    onFocusOutside(event) {
      props.onFocusOutside?.(event);
      if (event.defaultPrevented)
        return;
      const target = event.target;
      const isMenubarTrigger = getItems().some((item) => item?.contains(target));
      if (isMenubarTrigger)
        event.preventDefault();
    },
    onInteractOutside(event) {
      props.onInteractOutside?.(event);
      if (event.defaultPrevented)
        return;
      hasInteractedOutsideRef = true;
    },
    onEntryFocus(event) {
      if (!menuContext.wasKeyboardTriggerOpenRef.value)
        event.preventDefault();
    }
  });
  const attrs = {
    "id": menuContext.contentId,
    "aria-labelledby": menuContext.triggerId,
    "data-radix-menubar-content": "",
    "style": {
      // re-namespace exposed content custom properties
      "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
      "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
      "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
    },
    onKeydown
  };
  return {
    wrapperAttrs: menuContentImpl.wrapperAttrs,
    attrs(extraAttrs = []) {
      return menuContentImpl.attrs([attrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenubarContentImpl",
    inheritAttrs: false
  },
  __name: "MenubarContentImpl",
  props: /* @__PURE__ */ mergeDefaults({
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {}
  }, DEFAULT_MENUBAR_CONTENT_IMPL_PROPS),
  emits: ["closeAutoFocus", "escapeKeydown", "pointerdownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const menubarContentImpl = useMenubarContentImpl(convertPropsToHookProps(
      props,
      ["collisionBoundary"],
      () => ({
        onCloseAutoFocus(event) {
          emit("closeAutoFocus", event);
        },
        onEscapeKeydown(event) {
          emit("escapeKeydown", event);
        },
        onPointerdownOutside(event) {
          emit("pointerdownOutside", event);
        },
        onFocusOutside(event) {
          emit("focusOutside", event);
        },
        onInteractOutside(event) {
          emit("interactOutside", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", normalizeProps(guardReactiveProps(unref(menubarContentImpl).wrapperAttrs())), [
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menubarContentImpl).attrs([_ctx.$attrs])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16)
      ], 16);
    };
  }
});

const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenubarContent"
  },
  __name: "MenubarContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_MENUBAR_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const menubarContent = useMenubarContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(menubarContent).isPresent.value ? (openBlock(), createBlock(_sfc_main$8, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenubarMenu",
    inheritAttrs: false
  },
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(__props) {
    const props = __props;
    useMenubarMenu(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenubarRoot",
    inheritAttrs: false
  },
  __name: "MenubarRoot",
  props: /* @__PURE__ */ mergeDefaults({
    value: {},
    defaultValue: {},
    loop: { type: Boolean },
    dir: {}
  }, DEFAULT_MENUBAR_ROOT_PROPS),
  emits: ["update:value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const menuvarRoot = useMenuvarRoot(convertPropsToHookProps(
      props,
      ["value", "dir"],
      () => ({
        onUpdateValue(value) {
          emit("update:value", value);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menuvarRoot).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

function useMenubarSub(props) {
  const open = useControllableStateV2(props.open, props.onUpdateOpen, props.defaultOpen ?? false);
  useMenuSub({
    open() {
      return open.value;
    },
    onUpdateOpen(v) {
      open.value = v;
    }
  });
}

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenubarSub",
    inheritAttrs: false
  },
  __name: "MenubarSub",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: false }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useMenubarSub({
      open() {
        return props.open;
      },
      onUpdateOpen(open) {
        emit("update:open", open);
      },
      defaultOpen: props.defaultOpen
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const DEFAULT_MENUBAR_SUB_CONTENT_PROPS = {
  forceMount: void 0
};
const useMenubarSubContent = useMenuSubContent;

const DEFAULT_MENUBAR_SUB_CONTENT_IMPL_PROPS = {
  avoidCollisions: void 0,
  hideWhenDetached: void 0,
  loop: void 0
};
function useMenubarSubContentImpl(props = {}) {
  const menuSubContentImpl = useMenuSubContentImpl(props);
  const attrs = {
    "data-radix-menubar-content": "",
    "style": {
      "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
      "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
      "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
    }
  };
  return {
    wrapperAttrs: menuSubContentImpl.wrapperAttrs,
    attrs(extraAttrs = []) {
      return menuSubContentImpl.attrs([attrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenubarSubContentImpl",
    inheritAttrs: false
  },
  __name: "MenubarSubContentImpl",
  props: /* @__PURE__ */ mergeDefaults({
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {}
  }, DEFAULT_MENUBAR_SUB_CONTENT_IMPL_PROPS),
  emits: ["escapeKeydown", "pointerdownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const menubarContentImpl = useMenubarSubContentImpl(convertPropsToHookProps(
      props,
      ["collisionBoundary"],
      () => ({
        onEscapeKeydown(event) {
          emit("escapeKeydown", event);
        },
        onPointerdownOutside(event) {
          emit("pointerdownOutside", event);
        },
        onFocusOutside(event) {
          emit("focusOutside", event);
        },
        onInteractOutside(event) {
          emit("interactOutside", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", normalizeProps(guardReactiveProps(unref(menubarContentImpl).wrapperAttrs())), [
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menubarContentImpl).attrs([_ctx.$attrs])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16)
      ], 16);
    };
  }
});

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenubarSubContent"
  },
  __name: "MenubarSubContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_MENUBAR_SUB_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const menuContent = useMenubarSubContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(menuContent).isPresent.value ? (openBlock(), createBlock(_sfc_main$3, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const DEFAULT_MENUBAR_SUB_TRIGGER_PROPS = {
  disabled: void 0
};
function useMenubarSubTrigger(props = {}) {
  const menuSubTrigger = useMenuSubTrigger(props);
  const attrs = {
    "data-radix-menubar-subtrigger": ""
  };
  return {
    attrs(extraAttrs = []) {
      return menuSubTrigger.attrs([attrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenubarSubTrigger",
    inheritAttrs: false
  },
  __name: "MenubarSubTrigger",
  props: /* @__PURE__ */ mergeDefaults({
    disabled: { type: Boolean },
    textValue: {}
  }, DEFAULT_MENUBAR_SUB_TRIGGER_PROPS),
  setup(__props) {
    const props = __props;
    const menubarSubTrigger = useMenubarSubTrigger(convertPropsToHookProps(props, ["disabled"]));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menubarSubTrigger).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const DEFAULT_MENUBAR_TRIGGER_PROPS = {
  as: "button",
  disabled: void 0
};
function useMenubarTrigger(props = {}) {
  const context = useMenubarContext("MenubarTrigger");
  const menuContext = useMenubarMenuContext("MenubarTrigger");
  const popperContext = usePopperContext("MenubarTrigger");
  const itemData = {
    value: menuContext.value,
    disabled: props.disabled?.() ?? false
  };
  watchEffect(() => {
    itemData.value = menuContext.value;
    itemData.disabled = props.disabled?.() ?? false;
  });
  const isFocused = shallowRef(false);
  const open = computed(() => context.value.value === menuContext.value);
  function onPointerdown(event) {
    if (event.defaultPrevented)
      return;
    if (event.button === 0 && event.ctrlKey === false) {
      context.onMenuOpen(menuContext.value);
      if (!open.value)
        event.preventDefault();
    }
  }
  function onPointerenter(event) {
    if (event.defaultPrevented)
      return;
    const menubarOpen = Boolean(context.value.value);
    if (menubarOpen && !open.value) {
      context.onMenuOpen(menuContext.value);
      menuContext.triggerRef.value?.focus();
    }
  }
  function onKeydown(event) {
    if (event.defaultPrevented)
      return;
    if (["Enter", " "].includes(event.key))
      context.onMenuToggle(menuContext.value);
    if (event.key === "ArrowDown")
      context.onMenuOpen(menuContext.value);
    if (["Enter", " ", "ArrowDown"].includes(event.key)) {
      menuContext.wasKeyboardTriggerOpenRef.value = true;
      event.preventDefault();
    }
  }
  function onFocus(event) {
    if (event.defaultPrevented)
      return;
    isFocused.value = true;
  }
  function onBlur(event) {
    if (event.defaultPrevented)
      return;
    isFocused.value = false;
  }
  function setElRef(v) {
    menuContext.triggerRef.value = v;
    Collection.useCollectionItem(v, itemData, "$menubar");
  }
  onMounted(() => {
    popperContext.onAnchorChange(menuContext.triggerRef.value);
  });
  const rovingFocusGroupItem = useRovingFocusGroupItem({
    focusable() {
      return !props.disabled?.();
    },
    tabStopId() {
      return menuContext.value;
    }
  });
  return {
    attrs(extraAttrs = []) {
      const _open = open.value;
      const _disabled = props.disabled?.();
      const rovingFocusGroupItemAttrs = {
        "id": menuContext.triggerId,
        "elRef": setElRef,
        "type": "button",
        "role": "menuitem",
        "aria-haspopup": "menu",
        "aria-expanded": _open,
        "aria-controls": _open ? menuContext.contentId : void 0,
        "data-highlighted": isFocused.value ? "" : void 0,
        "data-state": _open ? "open" : "closed",
        "data-disabled": _disabled ? "" : void 0,
        "disabled": _disabled,
        [DATA_COLLECTION_ITEM]: true,
        onPointerdown,
        onPointerenter,
        onKeydown,
        onFocus,
        onBlur
      };
      return rovingFocusGroupItem.attrs([rovingFocusGroupItemAttrs, ...extraAttrs]);
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenubarTrigger",
    inheritAttrs: false
  },
  __name: "MenubarTrigger",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    disabled: { type: Boolean }
  }, DEFAULT_MENUBAR_TRIGGER_PROPS),
  setup(__props) {
    const props = __props;
    const menubarTrigger = useMenubarTrigger(convertPropsToHookProps(props, ["disabled"]));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menubarTrigger).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_MENUBAR_CONTENT_PROPS as D, _sfc_main$7 as _, DEFAULT_MENUBAR_CONTENT_IMPL_PROPS as a, useMenubarContentImpl as b, _sfc_main$8 as c, useMenubarMenu as d, useMenubarMenuContext as e, _sfc_main$6 as f, DEFAULT_MENUBAR_ROOT_PROPS as g, provideMenubarContext as h, useMenubarContext as i, useMenuvarRoot as j, _sfc_main$5 as k, useMenubarSub as l, _sfc_main$4 as m, DEFAULT_MENUBAR_SUB_CONTENT_PROPS as n, useMenubarSubContent as o, provideMenubarMenuContext as p, _sfc_main$2 as q, DEFAULT_MENUBAR_SUB_TRIGGER_PROPS as r, useMenubarSubTrigger as s, _sfc_main$1 as t, useMenubarContent as u, DEFAULT_MENUBAR_TRIGGER_PROPS as v, useMenubarTrigger as w, _sfc_main as x };
//# sourceMappingURL=menubar.mjs.map
