import { P as PatchFlags, i as isOn, h as isArray, N as NOOP } from './menu.mjs';
import { Fragment, Comment, normalizeClass, normalizeStyle } from 'vue';

function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented)
      ourEventHandler?.(event);
  };
}

function convertPropsToHookProps(props, reactiveProps, emits) {
  const result = emits ? { ...props, ...emits() } : { ...props };
  if (!reactiveProps) {
    return result;
  }
  for (const field of reactiveProps) {
    result[field] = () => props[field];
  }
  return result;
}

function focusFirst(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return true;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return true;
  }
  return false;
}

const isDef = (val) => typeof val !== "undefined";
const isPropFalsy = (val) => val == null || val === false;
function isNumber(value) {
  return typeof value === "number";
}
function arrayify(value) {
  return Array.isArray(value) ? value : [value];
}
function wrapArray(array, startIndex) {
  const ret = [];
  for (let i = 0; i < array.length; i++) {
    ret.push(array[(startIndex + i) % array.length]);
  }
  return ret;
}
function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}
function roundValue(value, decimalCount) {
  const rounder = 10 ** decimalCount;
  return Math.round(value * rounder) / rounder;
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}

function getElFromTemplateRef(nodeRef) {
  let node = nodeRef?.$el ?? nodeRef;
  if (node && node.nodeType !== 1)
    node = void 0;
  return node;
}

function getRawChildren(children) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === Fragment) {
      if (child.patchFlag & PatchFlags.KEYED_FRAGMENT)
        keyedFragmentCount++;
      ret = ret.concat(
        getRawChildren(child.children)
      );
    } else if (child.type !== Comment) {
      ret.push(child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = PatchFlags.BAIL;
    }
  }
  return ret;
}

function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let isInside = false;
  const length = polygon.length;
  for (let i = 0, j = length - 1; i < length; j = i++) {
    const [xi, yi] = polygon[i] || [0, 0];
    const [xj, yj] = polygon[j] || [0, 0];
    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) {
      isInside = !isInside;
    }
  }
  return isInside;
}

function mergePrimitiveAttrs(attrs, extraAttrsList) {
  const ret = attrs;
  for (let i = 0; i < extraAttrsList.length; i++) {
    const extraAttrs = extraAttrsList[i];
    for (const propName in extraAttrs) {
      if (propName === "class") {
        if (ret.class !== extraAttrs.class) {
          ret.class = normalizeClass([ret.class, extraAttrs.class]);
        }
      } else if (propName === "style") {
        ret.style = normalizeStyle([ret.style, extraAttrs.style]);
      } else if (isOn(propName)) {
        const incoming = extraAttrs[propName];
        if (incoming) {
          const existing = ret[propName];
          if (existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
            ret[propName] = existing ? [].concat(incoming, existing) : incoming;
          }
        }
      } else if (propName === "ref") {
        const incoming = extraAttrs[propName];
        if (incoming) {
          const existing = ret[propName];
          ret[propName] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (propName === "elRef") {
        const incoming = extraAttrs[propName];
        if (incoming) {
          const existing = ret[propName];
          ret[propName] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (propName !== "") {
        ret[propName] = extraAttrs[propName];
      }
    }
  }
  return ret;
}
function normalizeAttrs(attrs) {
  const _elRef = attrs.elRef;
  delete attrs.elRef;
  let elRef;
  if (_elRef) {
    elRef = (templateRef2) => {
      const el = getElFromTemplateRef(templateRef2);
      if (Array.isArray(_elRef)) {
        for (const setRef of _elRef) {
          setRef(el);
        }
      } else {
        _elRef(el);
      }
    };
  }
  const _templateRef = attrs.ref;
  delete attrs.ref;
  let templateRef = _templateRef;
  if (_templateRef) {
    if (Array.isArray(_templateRef)) {
      templateRef = (templateRef2) => {
        for (const setRef of _templateRef) {
          setRef(templateRef2);
        }
      };
    }
  }
  if (elRef && templateRef) {
    attrs.ref = (vNodeRef) => {
      elRef(vNodeRef);
      templateRef(vNodeRef);
    };
  } else if (elRef) {
    attrs.ref = elRef;
  } else if (templateRef) {
    attrs.ref = templateRef;
  }
  const disabled = attrs.disabled === true || attrs["data-disabled"] != null || attrs["aria-disabled"] === true;
  if (disabled) {
    for (const propName in attrs) {
      if (isOn(propName) && attrs[propName] !== void 0) {
        attrs[propName] = NOOP;
      }
    }
  }
  return attrs;
}

export { isNumber as a, clamp as b, convertPropsToHookProps as c, getRawChildren as d, composeEventHandlers as e, focusFirst as f, getDecimalCount as g, arrayify as h, isPointInPolygon as i, isDef as j, isPropFalsy as k, getElFromTemplateRef as l, mergePrimitiveAttrs as m, normalizeAttrs as n, roundValue as r, wrapArray as w };
//# sourceMappingURL=shared.mjs.map
