import { provide, inject, computed, shallowRef, watch, nextTick, onMounted, toValue, onBeforeUnmount, useId as useId$1, onWatcherCleanup } from 'vue';
import { i as isClient, a as isIOS } from './avatar.mjs';

function createContext(contextName, defaultValue) {
  const key = Symbol(contextName);
  const provideContext = (state) => {
    provide(key, state);
  };
  const useContext = (consumerName, value) => {
    const state = inject(key, value ?? defaultValue);
    if (state === null)
      return state;
    if (!state) {
      throw new Error(`\`${consumerName}\` must be used within \`${contextName}\``);
    }
    return state;
  };
  return [provideContext, useContext, key];
}

function useBodyScrollLock() {
  if (!isClient)
    return () => {
    };
  const body = document.body;
  if (body.hasAttribute("data-scroll-lock"))
    return () => {
    };
  const html = document.documentElement;
  const bodyStyle = body.style;
  const originalStyles = {
    overflow: bodyStyle.overflow,
    overflowX: bodyStyle.overflowX,
    overflowY: bodyStyle.overflowY,
    position: bodyStyle.position,
    top: bodyStyle.top,
    left: bodyStyle.left,
    right: bodyStyle.right,
    bottom: bodyStyle.bottom,
    scrollBehavior: html.style.scrollBehavior
  };
  const initialOverflow = bodyStyle.overflow;
  const scrollY = window.scrollY;
  bodyStyle.top = `-${scrollY}px`;
  bodyStyle.overflowX = "hidden";
  html.style.scrollBehavior = "auto";
  if (body.scrollHeight > window.innerHeight)
    bodyStyle.setProperty("overflow-y", "scroll", "important");
  bodyStyle.position = "fixed";
  bodyStyle.left = "0";
  bodyStyle.right = "0";
  bodyStyle.bottom = "0";
  body.setAttribute("data-scroll-lock", "true");
  let stopTouchMoveListener;
  if (isIOS) {
    let onTouchmove = function(e) {
      preventDefault(e);
    };
    document.addEventListener("touchmove", onTouchmove, {
      passive: false
    });
    stopTouchMoveListener = () => {
      document.removeEventListener("touchmove", onTouchmove);
    };
  }
  const unlock = () => {
    bodyStyle.overflow = initialOverflow ?? "";
    body.removeAttribute("data-scroll-lock");
    bodyStyle.overflowY = originalStyles.overflowY;
    bodyStyle.position = originalStyles.position;
    bodyStyle.left = originalStyles.left;
    bodyStyle.right = originalStyles.right;
    bodyStyle.bottom = originalStyles.bottom;
    bodyStyle.top = originalStyles.top;
    window.scrollTo(0, scrollY);
    html.style.scrollBehavior = originalStyles.scrollBehavior;
    stopTouchMoveListener?.();
  };
  return unlock;
}
function preventDefault(event) {
  const _target = event.target;
  if (checkOverflowScroll(_target))
    return false;
  if (event.touches.length > 1)
    return true;
  if (event.preventDefault)
    event.preventDefault();
  return false;
}
function checkOverflowScroll(el) {
  const style = window.getComputedStyle(el);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && el.clientWidth < el.scrollWidth || style.overflowY === "auto" && el.clientHeight < el.scrollHeight) {
    return true;
  } else {
    const parent = el.parentNode;
    if (!parent || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}

function useComposedElements(cb) {
  function setRef(nodeRef) {
    let node = nodeRef?.$el ?? nodeRef;
    if (node && node.nodeType !== 1)
      node = void 0;
    cb(node);
  }
  return setRef;
}

function useControllableState(props, key, onChange, defaultValue) {
  if (props[key] !== void 0) {
    return computed({
      get() {
        return props[key] ?? defaultValue;
      },
      set(value) {
        onChange(value);
      }
    });
  }
  const proxy = shallowRef(defaultValue);
  let isUpdating = false;
  watch(
    () => props[key],
    (v) => {
      if (!isUpdating) {
        isUpdating = true;
        proxy.value = v;
        nextTick(() => isUpdating = false);
      }
    }
  );
  watch(
    proxy,
    (v) => {
      if (!isUpdating && v !== props[key])
        onChange(v);
    }
  );
  return proxy;
}
function useControllableStateV2(prop, onChange, defaultValue) {
  const _isDef = prop?.() !== void 0;
  if (_isDef) {
    return computed({
      get() {
        return prop?.() ?? defaultValue;
      },
      set(value) {
        onChange?.(value);
      }
    });
  }
  const proxy = shallowRef(defaultValue);
  let isUpdating = false;
  if (prop) {
    watch(
      prop,
      (v) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = v;
          nextTick(() => isUpdating = false);
        }
      }
    );
  }
  watch(
    proxy,
    (v) => {
      if (!isUpdating && v !== prop?.())
        onChange?.(v);
    }
  );
  return proxy;
}
function useControllableStateV3(prop, onChange, defaultValue) {
  const _isDef = prop?.() !== void 0;
  if (_isDef) {
    return computed({
      get() {
        return prop?.() ?? defaultValue();
      },
      set(value) {
        onChange?.(value);
      }
    });
  }
  const proxy = shallowRef(defaultValue());
  let isUpdating = false;
  if (prop) {
    watch(
      prop,
      (v) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = v;
          nextTick(() => isUpdating = false);
        }
      }
    );
  }
  watch(
    proxy,
    (v) => {
      if (!isUpdating && v !== prop?.())
        onChange?.(v);
    }
  );
  return proxy;
}

let registeredEscapeHandlers = [];
function cachedHandler(e) {
  const event = e;
  if (event.key !== "Escape")
    return;
  for (const registeredHandler of registeredEscapeHandlers) {
    registeredHandler(event);
  }
}
function useEscapeKeydown(handler, ownerDocument = globalThis?.document) {
  let document;
  onMounted(() => {
    if (registeredEscapeHandlers.length === 0) {
      document = toValue(ownerDocument);
      document.addEventListener("keydown", cachedHandler);
    }
    registeredEscapeHandlers.push(handler);
  });
  onBeforeUnmount(() => {
    registeredEscapeHandlers = registeredEscapeHandlers.filter(
      (registeredHandler) => registeredHandler !== handler
    );
    if (registeredEscapeHandlers.length === 0) {
      document?.removeEventListener("keydown", cachedHandler);
    }
  });
}

function useForwardElement(elRef) {
  function setRef(nodeRef) {
    let node = nodeRef?.$el ?? nodeRef;
    if (node && node.nodeType !== 1)
      node = void 0;
    elRef.value = node;
  }
  return setRef;
}

const useId = useId$1;

function useRef(initialValue) {
  return { value: initialValue };
}

function useSize(elementRef) {
  const size = shallowRef();
  watch(() => toValue(elementRef), (element) => {
    if (!element) {
      size.value = void 0;
      return;
    }
    size.value = { width: element.offsetWidth, height: element.offsetHeight };
    const resizeObserver = new ResizeObserver((entries) => {
      if (!Array.isArray(entries))
        return;
      if (!entries.length)
        return;
      const entry = entries[0];
      let width;
      let height;
      if (entry && "borderBoxSize" in entry) {
        const borderSizeEntry = entry.borderBoxSize;
        const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
        width = borderSize.inlineSize;
        height = borderSize.blockSize;
      } else {
        width = element.offsetWidth;
        height = element.offsetHeight;
      }
      size.value = { width, height };
    });
    resizeObserver.observe(element, { box: "border-box" });
    onWatcherCleanup(() => {
      resizeObserver.unobserve(element);
    });
  }, { flush: "post" });
  return size;
}

function useStateMachine(initialState, machine) {
  const state = shallowRef(initialState);
  function reducer(event) {
    const nextState = machine[state.value][event];
    return nextState ?? state.value;
  }
  function send(event) {
    state.value = reducer(event);
  }
  return [
    state,
    send
  ];
}

export { useRef as a, useId as b, createContext as c, useBodyScrollLock as d, useEscapeKeydown as e, useSize as f, useStateMachine as g, useControllableStateV3 as h, useComposedElements as i, useControllableState as j, useForwardElement as k, useControllableStateV2 as u };
//# sourceMappingURL=hooks.mjs.map
