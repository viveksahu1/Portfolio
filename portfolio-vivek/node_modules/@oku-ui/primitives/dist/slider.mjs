import { computed, defineComponent, openBlock, createBlock, unref, normalizeProps, guardReactiveProps, withCtx, renderSlot, mergeDefaults, shallowRef, onMounted, onBeforeUnmount, watch, createElementBlock, createVNode, createCommentVNode } from 'vue';
import { b as clamp, a as isNumber, m as mergePrimitiveAttrs, g as getDecimalCount, r as roundValue, n as normalizeAttrs, c as convertPropsToHookProps } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, a as useRef, h as useControllableStateV3, f as useSize } from './hooks.mjs';
import { c as createCollection, D as DATA_COLLECTION_ITEM } from './collection.mjs';
import { u as useDirection } from './direction.mjs';

function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function convertValueToPercentage(value, min, max) {
  const maxSteps = max - min;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min);
  return clamp(percentage, 0, 100);
}
function getLabel(index, totalValues) {
  if (totalValues > 2)
    return `Value ${index + 1} of ${totalValues}`;
  if (totalValues === 2)
    return ["Minimum", "Maximum"][index];
  return void 0;
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1)
    return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset = linearScale([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index) => values[index + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}

const PAGE_KEYS = ["PageUp", "PageDown"];
const ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
const BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
const DEFAULT_SLIDER_ROOT_PROPS = {
  as: "span",
  disabled: void 0,
  inverted: void 0,
  min: 0,
  max: 100,
  step: 1,
  minStepsBetweenThumbs: 0,
  defaultValue: (v) => isNumber(v.min) ? [v.min] : [0]
};
const [provideSliderContext, useSliderContext] = createContext("Slider");
const [Collection, useCollection] = createCollection("Slider");
const [provideSliderOrientationContext, useSliderOrientationContext] = createContext("SliderOrientation");
function useSliderRoot(props) {
  const {
    name = () => void 0,
    min = () => 0,
    max = () => 100,
    step = () => 1,
    disabled = () => false,
    orientation = "horizontal",
    minStepsBetweenThumbs = () => 0,
    defaultValue = () => {
      const _min = min();
      return isNumber(_min) ? [_min] : [0];
    }
  } = props;
  const el = props.el || useRef();
  const setElRef = props.el ? void 0 : (value) => el.value = value;
  Collection.provideCollectionContext(el);
  const thumbs = /* @__PURE__ */ new Set();
  const valueIndexToChangeRef = useRef(0);
  const values = useControllableStateV3(
    props.value,
    (v) => {
      const _thumbs = Array.from(thumbs);
      _thumbs[valueIndexToChangeRef.value]?.focus();
      props.onUpdateValue?.(v);
    },
    defaultValue
  );
  let valuesBeforeSlideStartRef = values.value;
  function onSliderSlideStart(value) {
    const closestIndex = getClosestValueIndex(values.value, value);
    updateValues(value, closestIndex);
  }
  function onSliderSlideMove(value) {
    updateValues(value, valueIndexToChangeRef.value);
  }
  function onSliderSlideEnd() {
    const prevValue = valuesBeforeSlideStartRef[valueIndexToChangeRef.value];
    const nextValue = values.value[valueIndexToChangeRef.value];
    const hasChanged = nextValue !== prevValue;
    if (hasChanged) {
      props.onValueCommit?.(values.value);
    }
  }
  function onSliderHomeKeydown() {
    updateValues(min(), 0, { commit: true });
  }
  function onSliderEndKeydown() {
    updateValues(max(), values.value.length - 1, { commit: true });
  }
  function onSliderStepKeydown({ event, direction: stepDirection }) {
    const isPageKey = PAGE_KEYS.includes(event.key);
    const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
    const multiplier = isSkipKey ? 10 : 1;
    const atIndex = valueIndexToChangeRef.value;
    const value = values.value[atIndex];
    const stepInDirection = step() * multiplier * stepDirection;
    updateValues(value + stepInDirection, atIndex, { commit: true });
  }
  function updateValues(value, atIndex, { commit } = { commit: false }) {
    const decimalCount = getDecimalCount(step());
    const snapToStep = roundValue(Math.round((value - min()) / step()) * step() + min(), decimalCount);
    const nextValue = clamp(snapToStep, min(), max());
    const prevValues = values.value;
    const nextValues = getNextSortedValues(values.value, nextValue, atIndex);
    if (!hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs() * step()))
      return;
    valueIndexToChangeRef.value = nextValues.indexOf(nextValue);
    const hasChanged = String(nextValues) !== String(prevValues);
    if (!hasChanged)
      return;
    if (commit) {
      props.onValueCommit?.(nextValues);
    }
    values.value = nextValues;
  }
  function onSliderPointerdown() {
    valuesBeforeSlideStartRef = values.value;
  }
  provideSliderContext({
    name,
    disabled,
    min,
    max,
    valueIndexToChangeRef,
    thumbs,
    values,
    orientation
  });
  const isHorisontal = orientation === "horizontal";
  const orientationLocalState = {
    reactSise: isHorisontal ? "width" : "height",
    rectStartEdge: isHorisontal ? "left" : "top",
    clientEdge: isHorisontal ? "x" : "y",
    slideDirectionSte: isHorisontal ? "from-left" : "from-bottom",
    slideDirectionEts: isHorisontal ? "from-right" : "from-top"
  };
  let rectRef;
  const direction = useDirection(props.dir);
  const isSlidingFromStart = computed(() => {
    if (isHorisontal) {
      const isLtr = direction.value === "ltr";
      return isLtr && !props.inverted || !isLtr && props.inverted;
    }
    return !props.inverted;
  });
  function getValueFromPointer(pointerPosition) {
    const rect = rectRef || el.value.getBoundingClientRect();
    const input = [0, rect[orientationLocalState.reactSise]];
    const output = isSlidingFromStart.value === isHorisontal ? [min(), max()] : [max(), min()];
    const value = linearScale(input, output);
    rectRef = rect;
    return value(pointerPosition - rect[orientationLocalState.rectStartEdge]);
  }
  function onOrientationSlideStart(event) {
    const value = getValueFromPointer(event[orientationLocalState.clientEdge]);
    onSliderSlideStart(value);
  }
  function onOrientationSlideMove(event) {
    const value = getValueFromPointer(event[orientationLocalState.clientEdge]);
    onSliderSlideMove(value);
  }
  function onOrientationSlideEnd() {
    rectRef = void 0;
    onSliderSlideEnd();
  }
  function onOrientationStepKeydown(event) {
    const slideDirection = isSlidingFromStart.value ? orientationLocalState.slideDirectionSte : orientationLocalState.slideDirectionEts;
    const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
    onSliderStepKeydown({ event, direction: isBackKey ? -1 : 1 });
  }
  const orientationContext = computed(() => {
    const _startEdge = isHorisontal ? "left" : "bottom";
    const _endEdge = isHorisontal ? "right" : "top";
    const startEdge = isSlidingFromStart.value ? _startEdge : _endEdge;
    const endEdge = isSlidingFromStart.value ? _endEdge : _startEdge;
    const direction2 = isSlidingFromStart.value ? 1 : -1;
    const size = isHorisontal ? "width" : "height";
    return { startEdge, endEdge, direction: direction2, size };
  });
  provideSliderOrientationContext(orientationContext);
  function onKeydown(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.key === "Home") {
      onSliderHomeKeydown();
      event.preventDefault();
    } else if (event.key === "End") {
      onSliderEndKeydown();
      event.preventDefault();
    } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
      onOrientationStepKeydown(event);
      event.preventDefault();
    }
  }
  function onPointerdown(event) {
    if (event.defaultPrevented) {
      return;
    }
    onSliderPointerdown();
    const target = event.target;
    target.setPointerCapture(event.pointerId);
    event.preventDefault();
    if (thumbs.has(target)) {
      target.focus();
    } else {
      onOrientationSlideStart(event);
    }
  }
  function onPointermove(event) {
    if (event.defaultPrevented) {
      return;
    }
    const target = event.target;
    if (target.hasPointerCapture(event.pointerId))
      onOrientationSlideMove(event);
  }
  function onPointerup(event) {
    if (event.defaultPrevented) {
      return;
    }
    const target = event.target;
    if (target.hasPointerCapture(event.pointerId)) {
      target.releasePointerCapture(event.pointerId);
      onOrientationSlideEnd();
    }
  }
  return {
    attrs(extraAttrs) {
      const _disabled = disabled();
      const attrs = {
        "elRef": setElRef,
        "dir": direction.value,
        "data-orientation": orientation,
        "aria-disabled": _disabled,
        "data-disabled": _disabled ? "" : void 0,
        "style": orientation === "horizontal" ? "--radix-slider-thumb-transform: translateX(-50%)" : "--radix-slider-thumb-transform: translateY(50%)",
        onKeydown,
        onPointerdown,
        onPointermove,
        onPointerup
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const DEFAULT_SLIDER_RANGE_PROPS = {
  as: "span"
};
function useSliderRange() {
  const context = useSliderContext("SliderRange");
  const orientation = useSliderOrientationContext("SliderRange");
  const percentages = computed(() => context.values.value.map((value) => convertValueToPercentage(value, context.min(), context.max())));
  const offsetStart = computed(() => context.values.value.length > 1 ? Math.min(...percentages.value) : 0);
  const offsetEnd = computed(() => 100 - Math.max(...percentages.value));
  return {
    attrs(extraAttrs) {
      const attrs = {
        "data-disabled": context.disabled() ? "" : void 0,
        "data-orientation": context.orientation,
        "style": {
          [orientation.value.startEdge]: `${offsetStart.value}%`,
          [orientation.value.endEdge]: `${offsetEnd.value}%`
        }
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "SliderRange",
    inheritAttrs: false
  },
  __name: "SliderRange",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_SLIDER_RANGE_PROPS),
  setup(__props) {
    const sliderRange = useSliderRange();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(sliderRange).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "SliderRoot",
    inheritAttrs: false
  },
  __name: "SliderRoot",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    name: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    min: {},
    max: {},
    step: {},
    minStepsBetweenThumbs: {},
    value: {},
    defaultValue: {},
    inverted: { type: Boolean }
  }, DEFAULT_SLIDER_ROOT_PROPS),
  emits: ["update:value", "valueCommit"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const sliderRoot = useSliderRoot(convertPropsToHookProps(props, [
      "value",
      "defaultValue",
      "name",
      "disabled",
      "dir",
      "min",
      "max",
      "step",
      "minStepsBetweenThumbs"
    ], () => ({
      onUpdateValue(value) {
        emit("update:value", value);
      },
      onValueCommit(value) {
        emit("valueCommit", value);
      }
    })));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(sliderRoot).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const DEFAULT_SLIDER_THUMB_PROPS = {
  as: "span"
};
function useSliderThumb(props = {}) {
  const el = props.el || shallowRef();
  const setElRef = props.el ? void 0 : (value2) => el.value = value2;
  const getItems = useCollection();
  const index = computed(() => el.value ? getItems().findIndex((item) => item === el.value) : -1);
  const context = useSliderContext("SliderThumbImpl");
  const orientation = useSliderOrientationContext("SliderThumbImpl");
  const isFormControl = computed(() => el.value ? Boolean(el.value.closest("form")) : true);
  const size = useSize(el);
  const value = computed(() => context.values.value[index.value]);
  const percent = computed(() => value.value === void 0 ? 0 : convertValueToPercentage(value.value, context.min(), context.max()));
  const label = computed(() => getLabel(index.value, context.values.value.length));
  const thumbInBoundsOffset = computed(() => {
    const orientationSize = size.value?.[orientation.value.size];
    return orientationSize ? getThumbInBoundsOffset(orientationSize, percent.value, orientation.value.direction) : 0;
  });
  onMounted(() => {
    context.thumbs.add(el.value);
  });
  onBeforeUnmount(() => {
    context.thumbs.delete(el.value);
  });
  function onFocus(event) {
    if (event.defaultPrevented) {
      return;
    }
    context.valueIndexToChangeRef.value = index.value;
  }
  return {
    bubbleInput: {
      name() {
        const propsName = props.name?.();
        if (propsName != null)
          return propsName;
        const contextName = context.name();
        return contextName ? contextName + (context.values.value.length > 1 ? "[]" : "") : void 0;
      },
      value,
      index
    },
    isFormControl,
    wrapperAttrs() {
      const attrs = {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [orientation.value.startEdge]: `calc(${percent.value}% + ${thumbInBoundsOffset.value}px)`
        }
      };
      return attrs;
    },
    attrs(extraAttrs) {
      const _orientation = context.orientation;
      const _disabled = context.disabled();
      const attrs = {
        "elRef": setElRef,
        "role": "slider",
        "aria-label": label.value,
        "aria-valuemin": context.min(),
        "aria-valuenow": value.value,
        "aria-valuemax": context.max(),
        "aria-orientation": _orientation,
        "data-orientation": _orientation,
        "data-disabled": _disabled ? "" : void 0,
        "tabindex": _disabled ? void 0 : 0,
        [DATA_COLLECTION_ITEM]: true,
        "style": {
          /**
           * There will be no value on initial render while we work out the index so we hide thumbs
           * without a value, otherwise SSR will render them in the wrong position before they
           * snap into the correct position during hydration which would be visually jarring for
           * slower connections.
           */
          ...value.value === void 0 ? { display: "none" } : void 0
        },
        onFocus
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _hoisted_1 = ["name", "value"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "SliderBubbleInput",
    inheritAttrs: false
  },
  __name: "SliderBubbleInput",
  props: {
    name: {},
    value: {}
  },
  setup(__props) {
    const props = __props;
    let input;
    function setElRef(vNode) {
      input = vNode;
    }
    watch(() => props.value, (value, prevValue) => {
      if (!input)
        return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const inputEvent = new Event("input", { bubbles: true });
        const changeEvent = new Event("change", { bubbles: true });
        setValue.call(input, value);
        input.dispatchEvent(inputEvent);
        input.dispatchEvent(changeEvent);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("input", {
        ref: setElRef,
        name: _ctx.name,
        type: "number",
        style: { "display": "none" },
        value: _ctx.value
      }, null, 8, _hoisted_1);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "SliderThumb",
    inheritAttrs: false
  },
  __name: "SliderThumb",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    name: {}
  }, DEFAULT_SLIDER_THUMB_PROPS),
  setup(__props) {
    const props = __props;
    const sliderThumb = useSliderThumb(convertPropsToHookProps(props, ["name"]));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", normalizeProps(guardReactiveProps(unref(sliderThumb).wrapperAttrs())), [
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(sliderThumb).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16),
        unref(sliderThumb).isFormControl.value ? (openBlock(), createBlock(_sfc_main$2, {
          key: 0,
          name: unref(sliderThumb).bubbleInput.name(),
          value: unref(sliderThumb).bubbleInput.value.value
        }, null, 8, ["name", "value"])) : createCommentVNode("", true)
      ], 16);
    };
  }
});

const DEFAULT_SLIDER_TRACK_PROPS = {
  as: "span"
};
function useSliderTrack() {
  const context = useSliderContext("SliderTrack");
  return {
    attrs(extraAttrs) {
      const attrs = {
        "data-disabled": context.disabled() ? "" : void 0,
        "data-orientation": context.orientation
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "SliderTrack",
    inheritAttrs: false
  },
  __name: "SliderTrack",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_SLIDER_TRACK_PROPS),
  setup(__props) {
    const sliderTrack = useSliderTrack();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(sliderTrack).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { ARROW_KEYS as A, BACK_KEYS as B, Collection as C, DEFAULT_SLIDER_RANGE_PROPS as D, PAGE_KEYS as P, _sfc_main$4 as _, DEFAULT_SLIDER_ROOT_PROPS as a, provideSliderOrientationContext as b, useSliderContext as c, useSliderOrientationContext as d, useSliderRoot as e, _sfc_main$3 as f, DEFAULT_SLIDER_THUMB_PROPS as g, useSliderThumb as h, _sfc_main$1 as i, DEFAULT_SLIDER_TRACK_PROPS as j, useSliderTrack as k, _sfc_main as l, provideSliderContext as p, useCollection as u };
//# sourceMappingURL=slider.mjs.map
