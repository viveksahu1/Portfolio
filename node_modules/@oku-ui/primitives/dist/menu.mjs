import { onMounted, onBeforeUnmount, shallowRef, watchEffect, defineComponent, openBlock, createBlock, unref, normalizeProps, guardReactiveProps, withCtx, renderSlot, mergeDefaults, mergeProps, createCommentVNode, onWatcherCleanup, useId } from 'vue';
import { i as isIndeterminate$1 } from './checkbox.mjs';
import { i as isPointInPolygon, w as wrapArray, f as focusFirst, m as mergePrimitiveAttrs, c as convertPropsToHookProps, n as normalizeAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { a as usePooperRoot, u as usePopperContext, b as usePopperContent } from './popper.mjs';
import { u as usePresence } from './presence.mjs';
import { c as createContext, a as useRef, d as useBodyScrollLock } from './hooks.mjs';
import { hideOthers } from 'aria-hidden';
import { c as createCollection, D as DATA_COLLECTION_ITEM } from './collection.mjs';
import { u as useDirection } from './direction.mjs';
import { u as useFocusGuards } from './focus-guards.mjs';
import { u as useFocusScope } from './focus-scope.mjs';
import { u as useDismissableLayer } from './dismissable-layer.mjs';
import { u as useRovingFocusGroupRoot, a as useRovingFocusGroupItem } from './roving-focus.mjs';

/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/



!!(process.env.NODE_ENV !== "production") ? Object.freeze({}) : {};
!!(process.env.NODE_ENV !== "production") ? Object.freeze([]) : [];
const NOOP = () => {
};
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";

const PatchFlags = {
  "KEYED_FRAGMENT": 128,
  "BAIL": -2};

const [provideMenuContext, useMenuContext] = createContext("Menu");
const [provideMenuRootContext, useMenuRootContext] = createContext("MenuRoot");
const [Collection, useCollection] = createCollection("Menu");
function useMenuRoot(props = {}) {
  const { open = () => false, modal = true } = props;
  const isUsingKeyboardRef2 = useIsUsingKeyboard();
  const direction = useDirection(props.dir);
  provideMenuContext({
    open,
    onOpenChange(open2) {
      props.onUpdateOpen?.(open2);
    }
  });
  provideMenuRootContext({
    onClose() {
      props.onUpdateOpen?.(false);
    },
    isUsingKeyboardRef: isUsingKeyboardRef2,
    dir: direction,
    modal
  });
  usePooperRoot();
}
const SELECTION_KEYS = ["Enter", " "];
const FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
const LAST_KEYS = ["ArrowUp", "PageDown", "End"];
const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
const SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
const SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
let subscribers = 0;
const isUsingKeyboardRef = useRef(false);
function handlePointer() {
  isUsingKeyboardRef.value = false;
}
function handleKeyDown() {
  isUsingKeyboardRef.value = true;
}
function useIsUsingKeyboard() {
  if (subscribers > 0)
    return isUsingKeyboardRef;
  onMounted(() => {
    if (subscribers > 0)
      return;
    subscribers += 1;
    document.addEventListener("keydown", handleKeyDown, { capture: true, passive: true });
    document.addEventListener("pointerdown", handlePointer, { capture: true, passive: true });
    document.addEventListener("pointermove", handlePointer, { capture: true, passive: true });
  });
  onBeforeUnmount(() => {
    if (subscribers <= 0)
      return;
    subscribers -= 1;
    document.removeEventListener("pointerdown", handlePointer, { capture: true });
    document.removeEventListener("pointermove", handlePointer, { capture: true });
    document.removeEventListener("keydown", handleKeyDown, { capture: true });
  });
  return isUsingKeyboardRef;
}

function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] || "" : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find((value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = [event.clientX, event.clientY];
  return isPointInPolygon(cursorPos, area);
}

const [provideMenuContentContext, useMenuContentContext] = createContext("MenuContent");
function useMenuContentImpl(props = {}) {
  const context = useMenuRootContext("MenuContentImpl");
  const useMenuContent = context.modal ? useMenuContentImplModal : useMenuContentImplNonModal;
  return useMenuContent(props);
}
function useMenuContentImplModal(props = {}) {
  const context = useMenuContext("MenuContentImpl");
  const popperContext = usePopperContext("MenuContentImpl");
  let clearHideOthers;
  onMounted(() => {
    if (popperContext.content.value)
      clearHideOthers = hideOthers(popperContext.content.value);
  });
  onBeforeUnmount(() => {
    clearHideOthers?.();
    clearHideOthers = void 0;
  });
  return useMenuContentImplShared({
    ...props,
    trapFocus() {
      return context.open();
    },
    disableOutsidePointerEvents() {
      return true;
    },
    disableOutsideScroll: true,
    // When focus is trapped, a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    onFocusOutside(event) {
      event.preventDefault();
    },
    onDismiss() {
      context.onOpenChange(false);
    }
  });
}
function useMenuContentImplNonModal(props = {}) {
  const context = useMenuContext("MenuContentImpl");
  return useMenuContentImplShared({
    ...props,
    trapFocus() {
      return false;
    },
    disableOutsidePointerEvents() {
      return false;
    },
    disableOutsideScroll: false,
    onDismiss() {
      context.onOpenChange(false);
    }
  });
}
function useMenuContentImplShared(props = {}) {
  const { loop = false } = props;
  const context = useMenuContext("MenuContentImpl");
  const rootContext = useMenuRootContext("MenuContentImpl");
  const popperContext = usePopperContext("MenuContentImpl");
  const currentItemId = shallowRef();
  const elRef = useRef();
  function setElRef(value) {
    elRef.value = value;
    popperContext.content.value = value;
  }
  const getItems = useCollection(Collection.provideCollectionContext(elRef));
  let timerRef = 0;
  const searchRef = useRef("");
  const pointerGraceTimerRef = useRef(0);
  let pointerGraceIntentRef;
  let pointerDirRef = "right";
  let lastPointerXRef = 0;
  const unlock = props.disableOutsideScroll ? useBodyScrollLock() : void 0;
  function handleTypeaheadSearch(key) {
    const search = searchRef.value + key;
    const items = getItems().filter((item) => !item.$$rcid.menu.disabled);
    const currentItem = document.activeElement;
    const currentMatch = items.find((item) => item === currentItem)?.$$rcid.menu.textValue;
    const values = items.map((item) => item.$$rcid.menu.textValue);
    const nextMatch = getNextMatch(values, search, currentMatch);
    const newItem = items.find((item) => item.$$rcid.menu.textValue === nextMatch);
    (function updateSearch(value) {
      searchRef.value = value;
      if (timerRef)
        window.clearTimeout(timerRef);
      timerRef = 0;
      if (value !== "") {
        timerRef = window.setTimeout(() => {
          updateSearch("");
          timerRef = 0;
        }, 1e3);
      }
    })(search);
    if (newItem) {
      setTimeout(() => {
        newItem.focus();
      });
    }
  }
  onBeforeUnmount(() => {
    if (timerRef)
      window.clearTimeout(timerRef);
    unlock?.();
  });
  useFocusGuards();
  function isPointerMovingToSubmenu(event) {
    const isMovingTowards = pointerDirRef === pointerGraceIntentRef?.side;
    return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef?.area);
  }
  provideMenuContentContext({
    onItemEnter(event) {
      if (isPointerMovingToSubmenu(event)) {
        event.preventDefault();
      }
    },
    onItemLeave(event) {
      if (isPointerMovingToSubmenu(event))
        return;
      popperContext.content.value?.focus();
      currentItemId.value = void 0;
    },
    onTriggerLeave(event) {
      if (isPointerMovingToSubmenu(event)) {
        event.preventDefault();
      }
    },
    searchRef,
    pointerGraceTimerRef,
    onPointerGraceIntentChange(intent) {
      pointerGraceIntentRef = intent;
    }
  });
  function onKeydown(event) {
    if (event.defaultPrevented)
      return;
    const target = event.target;
    const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
    const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
    const isCharacterKey = event.key.length === 1;
    if (isKeyDownInside) {
      if (event.key === "Tab") {
        event.preventDefault();
      }
      if (!isModifierKey && isCharacterKey)
        handleTypeaheadSearch(event.key);
    }
    const content = popperContext.content.value;
    if (event.target !== content)
      return;
    if (!FIRST_LAST_KEYS.includes(event.key))
      return;
    event.preventDefault();
    const candidateNodes = getItems().filter((item) => !item.$$rcid.menu.disabled);
    if (LAST_KEYS.includes(event.key))
      candidateNodes.reverse();
    focusFirst(candidateNodes);
  }
  function onBlur(event) {
    if (event.defaultPrevented)
      return;
    if (!event.currentTarget?.contains(event.target)) {
      if (timerRef)
        window.clearTimeout(timerRef);
      searchRef.value = "";
    }
  }
  function onPointermove(event) {
    if (event.defaultPrevented)
      return;
    if (event.pointerType !== "mouse")
      return;
    const target = event.target;
    const pointerXHasChanged = lastPointerXRef !== event.clientX;
    if (event.currentTarget?.contains(target) && pointerXHasChanged) {
      const newDir = event.clientX > lastPointerXRef ? "right" : "left";
      pointerDirRef = newDir;
      lastPointerXRef = event.clientX;
    }
  }
  const focusScope = useFocusScope({
    el: popperContext.content,
    trapped: props.trapFocus,
    onMountAutoFocus(event) {
      props.onOpenAutoFocus?.(event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
      popperContext.content.value?.focus({ preventScroll: true });
    },
    onUnmountAutoFocus: props.onCloseAutoFocus
  });
  const dismissableLayer = useDismissableLayer({
    el: popperContext.content,
    disableOutsidePointerEvents: props.disableOutsidePointerEvents,
    onInteractOutside: props.onInteractOutside,
    onEscapeKeydown: props.onEscapeKeydown,
    onDismiss: props.onDismiss,
    onFocusOutside: props.onFocusOutside,
    onPointerdownOutside: props.onPointerdownOutside
  });
  const rovingFocusGroupRoot = useRovingFocusGroupRoot({
    elRef,
    currentTabStopId() {
      return currentItemId.value;
    },
    onUpdateCurrentTabStopId(tabStopId) {
      currentItemId.value = tabStopId;
    },
    preventScrollOnEntryFocus: true,
    orientation: "vertical",
    loop,
    dir: rootContext.dir,
    onEntryFocus(event) {
      props.onEntryFocus?.(event);
      if (event.defaultPrevented)
        return;
      if (!rootContext.isUsingKeyboardRef.value) {
        event.preventDefault();
      }
    }
  });
  const popperContent = usePopperContent(props);
  return {
    wrapperAttrs: popperContent.wrapperAttrs,
    attrs(extraAttrs = []) {
      const popperAttrs = {
        "elRef": setElRef,
        "role": "menu",
        "aria-orientation": "vertical",
        "data-state": context.open() ? "open" : "closed",
        "data-radix-menu-content": "",
        "dir": rootContext.dir.value,
        "style": {
          outline: "none"
        },
        onKeydown,
        onBlur,
        onPointermove
      };
      return popperContent.attrs([rovingFocusGroupRoot.attrs(), dismissableLayer.attrs(), focusScope.attrs(), popperAttrs, ...extraAttrs]);
    }
  };
}

function useMenuItemImpl(props) {
  const contentContext = useMenuContentContext("MenuItemImpl");
  const el = shallowRef();
  const itemData = { disabled: props.disabled?.(), textValue: props.textValue || "" };
  watchEffect(() => {
    itemData.disabled = props.disabled?.();
    itemData.textValue = props.textValue ?? el.value?.textContent ?? "";
  });
  function setElRef(v) {
    el.value = v;
    Collection.useCollectionItem(v, itemData, "menu");
  }
  const isFocused = shallowRef(false);
  function onPointermove(event) {
    if (event.defaultPrevented)
      return;
    if (event.pointerType !== "mouse")
      return;
    contentContext.onItemEnter(event);
    if (!event.defaultPrevented) {
      const item = event.currentTarget;
      item?.focus({ preventScroll: true });
    }
  }
  function onPointerleave(event) {
    if (event.pointerType !== "mouse")
      return;
    contentContext.onItemLeave(event);
  }
  function onFocus(event) {
    if (event.defaultPrevented)
      return;
    isFocused.value = true;
  }
  function onBlur(event) {
    if (event.defaultPrevented)
      return;
    isFocused.value = false;
  }
  const rovingFocusGroupItem = useRovingFocusGroupItem({
    focusable() {
      return !props.disabled?.();
    }
  });
  return {
    attrs(extraAttrs = []) {
      const _disabled = props.disabled?.();
      const rovingFocusGroupItemAttrs = {
        "elRef": setElRef,
        [DATA_COLLECTION_ITEM]: true,
        "role": "menuitem",
        "data-highlighted": isFocused.value ? "" : void 0,
        "aria-disabled": _disabled || void 0,
        "data-disabled": _disabled ? "" : void 0,
        onPointermove,
        onPointerleave,
        onFocus,
        onBlur
      };
      return rovingFocusGroupItem.attrs([rovingFocusGroupItemAttrs, ...extraAttrs]);
    }
  };
}

const DEFAULT_MENU_ITEM_PROPS = {
  disabled: void 0
};
const ITEM_SELECT = "menu.itemSelect";
function useMenuItem(props = {}) {
  const rootContext = useMenuRootContext("MenuItem");
  const contentContext = useMenuContentContext("MenuItem");
  let elRef;
  function setElRef(v) {
    elRef = v;
  }
  let isPointerDownRef = false;
  function onClick(event) {
    if (event.defaultPrevented)
      return;
    if (!elRef)
      return;
    const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
    props.onSelect?.(itemSelectEvent);
    if (itemSelectEvent.defaultPrevented) {
      isPointerDownRef = false;
    } else {
      rootContext.onClose();
    }
  }
  function onPointerdown() {
    isPointerDownRef = true;
  }
  function onPointerup(event) {
    if (event.defaultPrevented)
      return;
    if (!isPointerDownRef)
      event.currentTarget?.click();
  }
  function onKeydown(event) {
    if (event.defaultPrevented)
      return;
    const isTypingAhead = contentContext.searchRef.value !== "";
    if (isTypingAhead && event.key === " ")
      return;
    if (SELECTION_KEYS.includes(event.key)) {
      event.currentTarget?.click();
      event.preventDefault();
    }
  }
  const menuItemImpl = useMenuItemImpl({
    disabled: props.disabled,
    textValue: props.textValue
  });
  const attrs = {
    elRef: setElRef,
    onClick,
    onPointerdown,
    onPointerup,
    onKeydown
  };
  return {
    attrs(extraAttrs = []) {
      return menuItemImpl.attrs([attrs, ...extraAttrs]);
    }
  };
}

const DEFAULT_MENU_ITEM_INDICATOR_PROPS = {
  as: "span",
  forceMount: void 0
};
const [provideItemIndicatorContext, useItemIndicatorContext] = createContext("MenuItemIndicator", {
  checked: () => false
});
function useMenuItemIndicator(props = {}) {
  const indicatorContext = useItemIndicatorContext("MenuItemIndicator");
  const el = props.el ?? shallowRef();
  const setElRef = props.el ? void 0 : (v) => el.value = v;
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(el, () => isIndeterminate$1(indicatorContext.checked()) || indicatorContext.checked() === true);
  return {
    isPresent,
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "data-state": getCheckedState(indicatorContext.checked())
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const DEFAULT_MENU_CHECKBOX_ITEM_PROPS = {
  disabled: void 0,
  checked: false
};
function useMenuCheckboxItem(props) {
  const { checked = () => false } = props;
  provideItemIndicatorContext({
    checked
  });
  const menuItem = useMenuItem({
    ...props,
    onSelect(event) {
      props?.onSelect?.(event);
      if (props.onUpdateChecked) {
        const _checked = checked();
        props.onUpdateChecked(isIndeterminate$1(_checked) ? true : !_checked);
      }
    }
  });
  return {
    attrs(extraAttrs = []) {
      const _checked = checked();
      const menuItemAttrs = {
        "role": "menuitemcheckbox",
        "aria-checked": isIndeterminate$1(_checked) ? "mixed" : _checked,
        "data-state": getCheckedState(_checked)
      };
      return menuItem.attrs([menuItemAttrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenuCheckboxItem",
    inheritAttrs: false
  },
  __name: "MenuCheckboxItem",
  props: /* @__PURE__ */ mergeDefaults({
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {}
  }, DEFAULT_MENU_CHECKBOX_ITEM_PROPS),
  emits: ["update:checked", "select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const menuCheckboxItem = useMenuCheckboxItem(convertPropsToHookProps(
      props,
      ["checked", "disabled"],
      () => ({
        onUpdateChecked(checked) {
          emit("update:checked", checked);
        },
        onSelect(event) {
          emit("select", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menuCheckboxItem).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

function useMenuContent(props = {}) {
  const context = useMenuContext("MenuContent");
  const popperContext = usePopperContext("MenuContent");
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(popperContext.content, context.open);
  return {
    isPresent
  };
}

const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenuGroup"
  },
  __name: "MenuGroup",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), { role: "group" }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      });
    };
  }
});

const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenuItem",
    inheritAttrs: false
  },
  __name: "MenuItem",
  props: /* @__PURE__ */ mergeDefaults({
    disabled: { type: Boolean },
    textValue: {}
  }, DEFAULT_MENU_ITEM_PROPS),
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const menuItem = useMenuItem(convertPropsToHookProps(
      props,
      ["disabled"],
      () => ({
        onSelect(event) {
          emit("select", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menuItem).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenuItemIndicator",
    inheritAttrs: false
  },
  __name: "MenuItemIndicator",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    forceMount: { type: Boolean }
  }, DEFAULT_MENU_ITEM_INDICATOR_PROPS),
  setup(__props) {
    const props = __props;
    const indicatorContext = useMenuItemIndicator(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(indicatorContext).isPresent.value ? (openBlock(), createBlock(unref(Primitive), normalizeProps(mergeProps({ key: 0 }, unref(normalizeAttrs)(unref(indicatorContext).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode("", true);
    };
  }
});

const [providRadioGroupContext, useRadioGroupContext] = createContext(
  "MenuRadioGroup",
  {
    value() {
      return void 0;
    },
    onValueChange() {
    }
  }
);
function useMenuRadioGroup(props) {
  const {
    value = () => void 0,
    onUpdateValue = NOOP
  } = props;
  providRadioGroupContext({
    value,
    onValueChange: onUpdateValue
  });
}

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenuRadioGroup"
  },
  __name: "MenuRadioGroup",
  props: {
    value: {}
  },
  emits: ["update:value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useMenuRadioGroup(convertPropsToHookProps(
      props,
      ["value"],
      () => ({
        onUpdateValue(value) {
          emit("update:value", value);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), { role: "group" }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      });
    };
  }
});

const DEFAULT_MENU_RADIO_ITEM_PROPS = {
  disabled: void 0
};
function useMenuRadioItem(props) {
  const context = useRadioGroupContext("MenuRadioItem");
  provideItemIndicatorContext({
    checked() {
      return props.value === context.value();
    }
  });
  const menuItem = useMenuItem({
    ...props.menuItemProps,
    onSelect(event) {
      props.menuItemProps?.onSelect?.(event);
      context.onValueChange(props.value);
    }
  });
  return {
    attrs(extraAttrs = []) {
      const _checked = props.value === context.value();
      const menuItemAttrs = {
        "role": "menuitemradio",
        "aria-checked": _checked,
        "data-state": getCheckedState(_checked)
      };
      return menuItem.attrs([menuItemAttrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenuRadioItem",
    inheritAttrs: false
  },
  __name: "MenuRadioItem",
  props: /* @__PURE__ */ mergeDefaults({
    value: {},
    disabled: { type: Boolean },
    textValue: {}
  }, DEFAULT_MENU_RADIO_ITEM_PROPS),
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const menuRadioItem = useMenuRadioItem(convertPropsToHookProps(
      props,
      ["disabled"],
      () => ({
        onSelect(event) {
          emit("select", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menuRadioItem).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenuSeparator"
  },
  __name: "MenuSeparator",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        role: "separator",
        "aria-orientation": "horizontal"
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      });
    };
  }
});

const [provideMenuSubContext, useMenuSubContext] = createContext("MenuSub");
function useMenuSub(props) {
  const parentMenuContext = useMenuContext("MenuSub");
  const trigger = useRef();
  watchEffect(() => {
    if (parentMenuContext.open() === false)
      props.onUpdateOpen(false);
    onWatcherCleanup(() => {
      props.onUpdateOpen(false);
    });
  });
  provideMenuContext({
    open: props.open,
    onOpenChange: props.onUpdateOpen
  });
  provideMenuSubContext({
    contentId: useId(),
    triggerId: useId(),
    trigger,
    onTriggerChange(el) {
      trigger.value = el;
    }
  });
  usePooperRoot();
}

function useMenuSubContent(props) {
  const context = useMenuContext("MenuSubContent");
  const popperContext = usePopperContext("MenuSubContent");
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(popperContext.content, context.open);
  return {
    isPresent
  };
}

function useMenuSubContentImpl(props) {
  const context = useMenuContext("MenuSubContent");
  const rootContext = useMenuRootContext("MenuSubContent");
  const subContext = useMenuSubContext("MenuSubContent");
  const popperContext = usePopperContext("MenuSubContent");
  function onOpenAutoFocus(event) {
    if (rootContext.isUsingKeyboardRef.value) {
      popperContext.content.value?.focus();
    }
    event.preventDefault();
  }
  function onCloseAutoFocus(event) {
    event.preventDefault();
  }
  function onFocusOutside(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.target !== subContext.trigger.value) {
      context.onOpenChange(false);
    }
  }
  function onEscapeKeydown(event) {
    if (event.defaultPrevented) {
      return;
    }
    rootContext.onClose();
    event.preventDefault();
  }
  function onKeydown(event) {
    if (event.defaultPrevented) {
      return;
    }
    const isKeyDownInside = event.currentTarget.contains(event.target);
    const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir.value].includes(event.key);
    if (isKeyDownInside && isCloseKey) {
      context.onOpenChange(false);
      subContext.trigger.value?.focus();
      event.preventDefault();
    }
  }
  const menuContentImplShared = useMenuContentImplShared({
    ...props,
    onOpenAutoFocus,
    onCloseAutoFocus,
    onFocusOutside,
    onEscapeKeydown,
    align: "start",
    side: rootContext.dir.value !== "rtl" ? "right" : "left"
  });
  const attrs = {
    "aria-labelledby": subContext.triggerId,
    onKeydown
  };
  return {
    wrapperAttrs: menuContentImplShared.wrapperAttrs,
    attrs(extraAttrs = []) {
      return menuContentImplShared.attrs([attrs, ...extraAttrs]);
    }
  };
}

const DEFAULT_MENU_SUB_TRIGGER_PROPS = {
  disabled: void 0
};
function useMenuSubTrigger(props = {}) {
  const context = useMenuContext("MenuSubTrigger");
  const rootContext = useMenuRootContext("MenuSubTrigger");
  const subContext = useMenuSubContext("MenuSubTrigger");
  const contentContext = useMenuContentContext("MenuSubTrigger");
  const popperContext = usePopperContext("MenuSubTrigger");
  function setElRef(v) {
    subContext.trigger.value = v;
  }
  onMounted(() => {
    popperContext.onAnchorChange(subContext.trigger.value);
  });
  let openTimerRef = 0;
  function clearOpenTimer() {
    if (openTimerRef) {
      window.clearTimeout(openTimerRef);
      openTimerRef = 0;
    }
  }
  onBeforeUnmount(() => {
    clearOpenTimer();
    if (contentContext.pointerGraceTimerRef.value) {
      window.clearTimeout(contentContext.pointerGraceTimerRef.value);
      contentContext.pointerGraceTimerRef.value = 0;
    }
    contentContext.onPointerGraceIntentChange(void 0);
  });
  function onClick(event) {
    if (event.defaultPrevented) {
      return;
    }
    event.currentTarget.focus();
    if (!context.open())
      context.onOpenChange(true);
  }
  function onPointermove(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.pointerType !== "mouse")
      return;
    contentContext.onItemEnter(event);
    if (event.defaultPrevented)
      return;
    if (!context.open() && !openTimerRef) {
      contentContext.onPointerGraceIntentChange(void 0);
      openTimerRef = window.setTimeout(() => {
        context.onOpenChange(true);
        clearOpenTimer();
        openTimerRef = 0;
      }, 100);
    }
  }
  function onPointerleave(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.pointerType !== "mouse")
      return;
    clearOpenTimer();
    const contentRect = popperContext.content.value?.getBoundingClientRect();
    if (contentRect) {
      const side = popperContext.content.value?.dataset.side;
      const rightSide = side === "right";
      const bleed = rightSide ? -5 : 5;
      const contentNearEdge = contentRect[rightSide ? "left" : "right"];
      const contentFarEdge = contentRect[rightSide ? "right" : "left"];
      contentContext.onPointerGraceIntentChange({
        area: [
          // Apply a bleed on clientX to ensure that our exit point is
          // consistently within polygon bounds
          [event.clientX + bleed, event.clientY],
          [contentNearEdge, contentRect.top],
          [contentFarEdge, contentRect.top],
          [contentFarEdge, contentRect.bottom],
          [contentNearEdge, contentRect.bottom]
        ],
        side
      });
      if (contentContext.pointerGraceTimerRef.value) {
        window.clearTimeout(contentContext.pointerGraceTimerRef.value);
      }
      contentContext.pointerGraceTimerRef.value = window.setTimeout(
        () => {
          contentContext.onPointerGraceIntentChange(void 0);
          contentContext.pointerGraceTimerRef.value = 0;
        },
        300
      );
    } else {
      contentContext.onTriggerLeave(event);
      if (event.defaultPrevented)
        return;
      contentContext.onPointerGraceIntentChange(void 0);
    }
  }
  function onKeydown(event) {
    if (event.defaultPrevented) {
      return;
    }
    const isTypingAhead = contentContext.searchRef.value !== "";
    if (isTypingAhead && event.key === " ")
      return;
    if (SUB_OPEN_KEYS[rootContext.dir.value].includes(event.key)) {
      context.onOpenChange(true);
      popperContext.content.value?.focus();
      event.preventDefault();
    }
  }
  const menuItem = useMenuItemImpl(props);
  return {
    attrs(extraAttrs = []) {
      const _open = context.open();
      const rovingFocusGroupItemAttrs = {
        "id": subContext.triggerId,
        "elRef": setElRef,
        "aria-haspopup": "menu",
        "aria-expanded": _open ? "true" : "false",
        "aria-controls": subContext.contentId,
        "data-state": _open ? "open" : "closed",
        onClick,
        onPointermove,
        onPointerleave,
        onKeydown
      };
      return menuItem.attrs([rovingFocusGroupItemAttrs, ...extraAttrs]);
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "MenuSubTrigger",
    inheritAttrs: false
  },
  __name: "MenuSubTrigger",
  props: /* @__PURE__ */ mergeDefaults({
    disabled: { type: Boolean },
    textValue: {}
  }, DEFAULT_MENU_SUB_TRIGGER_PROPS),
  setup(__props) {
    const props = __props;
    const menuSubTrigger = useMenuSubTrigger(convertPropsToHookProps(props, ["disabled"]));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(menuSubTrigger).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { NOOP as N, PatchFlags as P, _sfc_main$6 as _, useMenuRoot as a, useMenuContentImpl as b, useMenuSub as c, useMenuSubContent as d, useMenuSubContentImpl as e, useMenuContent as f, useMenuSubTrigger as g, isArray as h, isOn as i, _sfc_main$5 as j, _sfc_main$7 as k, _sfc_main$3 as l, _sfc_main$2 as m, _sfc_main$4 as n, _sfc_main$1 as o, _sfc_main as p, isFunction as q, useMenuContext as u };
//# sourceMappingURL=menu.mjs.map
