import { shallowRef, defineComponent, openBlock, createElementBlock, normalizeProps, guardReactiveProps, unref, createVNode, withCtx, renderSlot, mergeDefaults, createBlock, createCommentVNode, watchEffect, onWatcherCleanup, onBeforeUnmount } from 'vue';
import { u as useMenuContext, a as useMenuRoot, b as useMenuContentImpl, c as useMenuSub, d as useMenuSubContent, e as useMenuSubContentImpl } from './menu.mjs';
import { u as usePresence } from './presence.mjs';
import { u as usePopperContext } from './popper.mjs';
import { c as convertPropsToHookProps, n as normalizeAttrs, m as mergePrimitiveAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, u as useControllableStateV2 } from './hooks.mjs';
import { i as isClient } from './avatar.mjs';

const DEFAULT_CONTEXT_MENU_CONTENT_PROPS = {
  forceMount: void 0
};
function useContextMenuContent(props = {}) {
  const menuContext = useMenuContext("MenuContent");
  const popperContext = usePopperContext("MenuContent");
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(popperContext.content, menuContext.open);
  return {
    isPresent
  };
}

const DEFAULT_CONTEXT_MENU_ROOT_PROPS = {
  modal: void 0
};
const [provideContextMenuContext, useContextMenuContext] = createContext("ContextMenu");
function useContextMenuRoot(props) {
  const { modal = true } = props;
  const open = shallowRef(false);
  function onOpenChange(v) {
    open.value = v;
    props.onUpdateOpen?.(v);
  }
  provideContextMenuContext({
    open,
    onOpenChange,
    modal
  });
  useMenuRoot({
    open() {
      return open.value;
    },
    onUpdateOpen(v) {
      open.value = v;
    },
    dir: props.dir,
    modal
  });
}

const DEFAULT_CONTEXT_MENU_CONTENT_IMPL_PROPS = {
  avoidCollisions: void 0,
  hideWhenDetached: void 0,
  loop: void 0
};
function useContextMenuContentImpl(props = {}) {
  const context = useContextMenuContext("ContextMenuContent");
  let hasInteractedOutsideRef = false;
  const menuContentImpl = useMenuContentImpl({
    ...props,
    onCloseAutoFocus(event) {
      props.onCloseAutoFocus?.(event);
      if (!event.defaultPrevented && hasInteractedOutsideRef) {
        event.preventDefault();
      }
      hasInteractedOutsideRef = false;
    },
    onInteractOutside(event) {
      props.onInteractOutside?.(event);
      if (!event.defaultPrevented && !context.modal)
        hasInteractedOutsideRef = true;
    },
    side: "right",
    sideOffset: 2,
    align: "start"
  });
  const attrs = {
    style: {
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  };
  return {
    wrapperAttrs: menuContentImpl.wrapperAttrs,
    attrs(extraAttrs = []) {
      return menuContentImpl.attrs([attrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ContextMenuContentImpl",
    inheritAttrs: false
  },
  __name: "ContextMenuContentImpl",
  props: /* @__PURE__ */ mergeDefaults({
    loop: { type: Boolean },
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {}
  }, DEFAULT_CONTEXT_MENU_CONTENT_IMPL_PROPS),
  emits: ["closeAutoFocus", "escapeKeydown", "pointerdownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const contextMenuContentImpl = useContextMenuContentImpl(convertPropsToHookProps(
      props,
      ["collisionBoundary"],
      () => ({
        onCloseAutoFocus(event) {
          emit("closeAutoFocus", event);
        },
        onEscapeKeydown(event) {
          emit("escapeKeydown", event);
        },
        onPointerdownOutside(event) {
          emit("pointerdownOutside", event);
        },
        onFocusOutside(event) {
          emit("focusOutside", event);
        },
        onInteractOutside(event) {
          emit("interactOutside", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", normalizeProps(guardReactiveProps(unref(contextMenuContentImpl).wrapperAttrs())), [
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(contextMenuContentImpl).attrs([_ctx.$attrs])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16)
      ], 16);
    };
  }
});

const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ContextMenuContent"
  },
  __name: "ContextMenuContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_CONTEXT_MENU_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const menuContent = useContextMenuContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(menuContent).isPresent.value ? (openBlock(), createBlock(_sfc_main$6, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ContextMenuRoot",
    inheritAttrs: false
  },
  __name: "ContextMenuRoot",
  props: /* @__PURE__ */ mergeDefaults({
    dir: {},
    modal: { type: Boolean }
  }, DEFAULT_CONTEXT_MENU_ROOT_PROPS),
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useContextMenuRoot(convertPropsToHookProps(
      props,
      ["dir"],
      () => ({
        onUpdateOpen(open) {
          emit("update:open", open);
        }
      })
    ));
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const DEFAULT_CONTEXT_MENU_SUB_PROPS = {
  open: void 0,
  defaultOpen: void 0
};
function useContextMenuSub(props = {}) {
  const { defaultOpen = false } = props;
  const open = useControllableStateV2(props.open, props.onUpdateOpen, defaultOpen);
  useMenuSub({
    open() {
      return open.value;
    },
    onUpdateOpen(v) {
      open.value = v;
    }
  });
}

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ContextMenuSub",
    inheritAttrs: false
  },
  __name: "ContextMenuSub",
  props: /* @__PURE__ */ mergeDefaults({
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  }, DEFAULT_CONTEXT_MENU_SUB_PROPS),
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useContextMenuSub(convertPropsToHookProps(
      props,
      ["open"],
      () => ({
        onUpdateOpen(open) {
          emit("update:open", open);
        }
      })
    ));
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const DEFAULT_CONTEXT_MENU_SUB_CONTENT_PROPS = {
  forceMount: void 0
};
const useContextMenuSubContent = useMenuSubContent;

const DEFAULT_CONTEXT_MENU_SUB_CONTENT_IMPL_PROPS = {
  avoidCollisions: void 0,
  hideWhenDetached: void 0,
  loop: void 0
};
function useContextMenuSubContentImpl(props = {}) {
  const menuSubContentImpl = useMenuSubContentImpl(props);
  const attrs = {
    style: {
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  };
  return {
    wrapperAttrs: menuSubContentImpl.wrapperAttrs,
    attrs(extraAttrs = []) {
      return menuSubContentImpl.attrs([attrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ContextMenuSubContentImpl",
    inheritAttrs: false
  },
  __name: "ContextMenuSubContentImpl",
  props: /* @__PURE__ */ mergeDefaults({
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {}
  }, DEFAULT_CONTEXT_MENU_SUB_CONTENT_IMPL_PROPS),
  emits: ["escapeKeydown", "pointerdownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const contextMenuSubContentImpl = useContextMenuSubContentImpl(convertPropsToHookProps(
      props,
      ["collisionBoundary"],
      () => ({
        onEscapeKeydown(event) {
          emit("escapeKeydown", event);
        },
        onPointerdownOutside(event) {
          emit("pointerdownOutside", event);
        },
        onFocusOutside(event) {
          emit("focusOutside", event);
        },
        onInteractOutside(event) {
          emit("interactOutside", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", normalizeProps(guardReactiveProps(unref(contextMenuSubContentImpl).wrapperAttrs())), [
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(contextMenuSubContentImpl).attrs([_ctx.$attrs])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16)
      ], 16);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ContextMenuSubContent"
  },
  __name: "ContextMenuSubContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_CONTEXT_MENU_SUB_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const menuContent = useContextMenuSubContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(menuContent).isPresent.value ? (openBlock(), createBlock(_sfc_main$2, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const DEFAULT_CONTEXT_MENU_TRIGGER_PROPS = {
  as: "span",
  disabled: void 0
};
function useContextMenuTrigger(props = {}) {
  const context = useContextMenuContext("ContextMenuTrigger");
  const popperContext = usePopperContext("ContextMenuTrigger");
  const pointRef = { width: 0, height: 0, x: 0, y: 0 };
  const virtualRef = {
    getBoundingClientRect() {
      return DOMRect.fromRect(pointRef);
    }
  };
  let longPressTimerRef = 0;
  function clearLongPress() {
    window.clearTimeout(longPressTimerRef);
  }
  function handleOpen(event) {
    pointRef.x = event.clientX;
    pointRef.y = event.clientY;
    context.onOpenChange(true);
  }
  if (isClient) {
    watchEffect(() => {
      if (props.disabled?.()) {
        clearLongPress();
      }
      onWatcherCleanup(() => {
        clearLongPress();
      });
    });
  }
  function onContextmenu(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (props.disabled?.()) {
      return;
    }
    clearLongPress();
    handleOpen(event);
    event.preventDefault();
  }
  function onPointerdown(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.pointerType === "mouse")
      return;
    clearLongPress();
    longPressTimerRef = window.setTimeout(() => handleOpen(event), 700);
  }
  function onPointermove(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.pointerType === "mouse")
      return;
    clearLongPress();
  }
  function onPointercancel(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.pointerType === "mouse")
      return;
    clearLongPress();
  }
  function onPointerup(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.pointerType === "mouse")
      return;
    clearLongPress();
  }
  onBeforeUnmount(() => {
    clearLongPress();
  });
  popperContext.onAnchorChange(virtualRef);
  return {
    attrs(extraAttrs) {
      const attrs = {
        "data-state": context.open.value ? "open" : "closed",
        "data-disabled": props.disabled?.() ? "" : void 0,
        "style": "-webkit-touch-callout: none;",
        onContextmenu,
        onPointerdown,
        onPointermove,
        onPointercancel,
        onPointerup
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "ContextMenuTrigger",
    inheritAttrs: false
  },
  __name: "ContextMenuTrigger",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    disabled: { type: Boolean }
  }, DEFAULT_CONTEXT_MENU_TRIGGER_PROPS),
  setup(__props) {
    const props = __props;
    const contextMenuTrigger = useContextMenuTrigger(convertPropsToHookProps(props, ["disabled"]));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(contextMenuTrigger).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_CONTEXT_MENU_CONTENT_PROPS as D, _sfc_main$5 as _, DEFAULT_CONTEXT_MENU_ROOT_PROPS as a, useContextMenuContext as b, _sfc_main$4 as c, DEFAULT_CONTEXT_MENU_SUB_PROPS as d, useContextMenuSub as e, _sfc_main$3 as f, _sfc_main$1 as g, _sfc_main as h, provideContextMenuContext as p, useContextMenuContent as u };
//# sourceMappingURL=context-menu.mjs.map
