import { shallowRef, computed, watch, onWatcherCleanup, watchEffect } from 'vue';
import { c as createContext, u as useControllableStateV2, a as useRef, b as useId } from './hooks.mjs';
import { c as createCollection, D as DATA_COLLECTION_ITEM } from './collection.mjs';
import { u as useDirection } from './direction.mjs';
import { m as mergePrimitiveAttrs, f as focusFirst, w as wrapArray } from './shared.mjs';

const ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
const EVENT_OPTIONS = { bubbles: false, cancelable: true };
const MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}

const [Collection, useCollection] = createCollection("RovingFocusGroup");
const [provideRovingFocusContext, useRovingFocusContext] = createContext("RovingFocusGroup");
function useRovingFocusGroupRoot(props) {
  const {
    loop = false
  } = props;
  const elRef = props.elRef || useRef();
  const setElRef = props.elRef ? void 0 : (value) => elRef.value = value;
  const dir = useDirection(props.dir);
  const currentTabStopId = useControllableStateV2(props.currentTabStopId, props.onUpdateCurrentTabStopId, props.defaultCurrentTabStopId);
  const collectionContext = Collection.provideCollectionContext(elRef);
  const getItems = useCollection(collectionContext);
  const isTabbingBackOut = shallowRef(false);
  let isClickFocus = false;
  const focusableItemsCount = shallowRef(0);
  function onMousedown(event) {
    if (event.defaultPrevented)
      return;
    isClickFocus = true;
  }
  function onFocusin(event) {
    if (event.defaultPrevented)
      return;
    const isKeyboardFocus = !isClickFocus;
    if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut.value) {
      const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
      props.onEntryFocus?.(entryFocusEvent);
      if (!entryFocusEvent.defaultPrevented) {
        const items = getItems().filter((item) => item.$$rcid.$rfg.focusable);
        const activeItem = items.find((item) => item.$$rcid.$rfg.active);
        const _currentTabStopId = currentTabStopId.value;
        const currentItem = items.find((item) => item.$$rcid.$rfg.id === _currentTabStopId);
        const candidateItems = [activeItem, currentItem, ...items].filter(Boolean);
        focusFirst(candidateItems, props.preventScrollOnEntryFocus ?? false);
      }
    }
    isClickFocus = false;
  }
  function onFocusout(event) {
    if (event.defaultPrevented)
      return;
    isTabbingBackOut.value = false;
  }
  provideRovingFocusContext({
    orientation: props.orientation,
    dir,
    loop,
    currentTabStopId,
    onItemFocus(tabStopId) {
      currentTabStopId.value = tabStopId;
    },
    onItemShiftTab() {
      isTabbingBackOut.value = true;
    },
    onFocusableItemAdd() {
      focusableItemsCount.value += 1;
    },
    onFocusableItemRemove() {
      focusableItemsCount.value -= 1;
    }
  });
  const tabindex = computed(() => isTabbingBackOut.value || focusableItemsCount.value === 0 ? -1 : 0);
  const style = { outline: "none" };
  return {
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "dir": dir.value,
        "tabindex": tabindex.value,
        "data-orientation": props.orientation,
        "style": style,
        onMousedown,
        onFocusin,
        onFocusout
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

function useRovingFocusGroupItem(props = {}) {
  const {
    focusable = () => true,
    active = () => false
  } = props;
  const _id = useId();
  const id = computed(() => props.tabStopId?.() ?? _id);
  const context = useRovingFocusContext("RovingFocusGroupItem");
  const isCurrentTabStop = computed(() => context.currentTabStopId.value === id.value);
  const getItems = useCollection();
  watch(focusable, (value) => {
    if (value) {
      context.onFocusableItemAdd();
      onWatcherCleanup(context.onFocusableItemRemove);
    }
  }, { immediate: true });
  const itemData = { id: id.value, focusable: focusable(), active: active() };
  watchEffect(() => {
    itemData.active = active();
    itemData.focusable = focusable();
    itemData.id = id.value;
  });
  function onMousedown(event) {
    if (event.defaultPrevented)
      return;
    if (!focusable())
      event.preventDefault();
    else context.onItemFocus(id.value);
  }
  function onFocus(event) {
    if (event.defaultPrevented)
      return;
    context.onItemFocus(id.value);
  }
  function onKeydown(event) {
    if (event.defaultPrevented)
      return;
    if (event.key === "Tab" && event.shiftKey) {
      context.onItemShiftTab();
      return;
    }
    if (event.target !== event.currentTarget)
      return;
    if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)
      return;
    const focusIntent = getFocusIntent(event, context.orientation, context.dir.value);
    if (!focusIntent)
      return;
    event.preventDefault();
    let candidateNodes = getItems().filter((item) => item.$$rcid.$rfg.focusable);
    if (focusIntent === "last") {
      candidateNodes.reverse();
    } else if (focusIntent === "prev" || focusIntent === "next") {
      if (focusIntent === "prev") {
        candidateNodes.reverse();
      }
      const currentIndex = candidateNodes.indexOf(event.currentTarget);
      candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
    }
    setTimeout(() => {
      focusFirst(candidateNodes);
    });
  }
  function setElRef(templateEl) {
    Collection.useCollectionItem(templateEl, itemData, "$rfg");
  }
  return {
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        [DATA_COLLECTION_ITEM]: true,
        "tabindex": isCurrentTabStop.value ? 0 : -1,
        "data-orientation": context.orientation,
        onFocus,
        onMousedown,
        onKeydown
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

export { useRovingFocusGroupItem as a, useRovingFocusGroupRoot as u };
//# sourceMappingURL=roving-focus.mjs.map
