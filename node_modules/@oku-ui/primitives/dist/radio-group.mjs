import { shallowRef, computed, onMounted, onBeforeUnmount, defineComponent, watch, openBlock, createElementBlock, unref, createBlock, normalizeProps, mergeProps, withCtx, renderSlot, createCommentVNode, mergeDefaults, guardReactiveProps } from 'vue';
import { u as usePresence } from './presence.mjs';
import { m as mergePrimitiveAttrs, c as convertPropsToHookProps, n as normalizeAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, a as useRef, u as useControllableStateV2 } from './hooks.mjs';
import { u as useRovingFocusGroupRoot, a as useRovingFocusGroupItem } from './roving-focus.mjs';
import { u as useDirection } from './direction.mjs';

const DEFAULT_RADIO_GROUP_ROOT_PROPS = {
  disabled: void 0,
  required: void 0,
  loop: void 0
};
const [provideRadioGroupContext, useRadioGroupContext] = createContext("RadioGroup");
function useRadioGroupRoot(props) {
  const {
    loop = true,
    name = () => void 0,
    disabled = () => void 0,
    required = () => void 0
  } = props;
  const elRef = props.elRef || useRef();
  const setElRef = props.elRef ? void 0 : (value2) => elRef.value = value2;
  const direction = useDirection(props.dir);
  const value = useControllableStateV2(props.value, props.onUpdateValue, props.defaultValue);
  provideRadioGroupContext({
    name,
    required,
    disabled,
    value,
    onValueChange(v) {
      value.value = v;
    }
  });
  const rovingFocusGroupRoot = useRovingFocusGroupRoot({
    orientation: props.orientation,
    loop,
    dir: direction
  });
  return {
    attrs(extraAttrs = []) {
      const attrs = {
        "elRef": setElRef,
        "role": "radiogroup",
        "aria-required": props.required?.(),
        "aria-orientation": props.orientation,
        "data-disabled": disabled() ? "" : void 0
      };
      mergePrimitiveAttrs(attrs, [rovingFocusGroupRoot.attrs(), ...extraAttrs]);
      return attrs;
    }
  };
}

const DEFAULT_RADIO_GROUP_ITEM_PROPS = {
  as: "button",
  disabled: void 0
};
const ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
const [provideRadioContext, useRadioContext] = createContext("Radio");
function useRadioGroupItem(props) {
  const control = props.control || shallowRef();
  const setElRef = props.control ? void 0 : (value) => control.value = value;
  const context = useRadioGroupContext("RadioGroupItem");
  const disabled = computed(() => context.disabled() || props.disabled?.());
  const checked = computed(() => context.value.value === props.value());
  let isArrowKeyPressed = false;
  function onDocumentKeydown(event) {
    if (ARROW_KEYS.includes(event.key)) {
      isArrowKeyPressed = true;
    }
  }
  function onDocumentKeyup() {
    isArrowKeyPressed = false;
  }
  onMounted(() => {
    document.addEventListener("keydown", onDocumentKeydown);
    document.addEventListener("keyup", onDocumentKeyup);
  });
  onBeforeUnmount(() => {
    document.removeEventListener("keydown", onDocumentKeydown);
    document.removeEventListener("keyup", onDocumentKeyup);
  });
  function onCheck() {
    context.onValueChange(props.value());
  }
  function onKeydown(event) {
    if (event.defaultPrevented)
      return;
    if (event.key === "Enter")
      event.preventDefault();
  }
  function onFocus(event) {
    if (event.defaultPrevented)
      return;
    if (isArrowKeyPressed)
      control.value?.click();
  }
  const bubbles = useRef(true);
  const isFormControl = useRef(false);
  function onClick(event) {
    if (event.defaultPrevented)
      return;
    if (!checked.value)
      onCheck();
    if (!isFormControl.value)
      return;
    bubbles.value = !event.cancelBubble;
  }
  provideRadioContext({
    checked,
    disabled,
    bubbleInput: {
      control,
      bubbles,
      isFormControl,
      name: context.name,
      value: props.value,
      checked,
      required: context.required,
      disabled
    }
  });
  const rovingFocusGroupItem = useRovingFocusGroupItem({
    focusable() {
      return !disabled.value;
    },
    active() {
      return checked.value;
    }
  });
  return {
    attrs(extraAttrs = []) {
      const _disabled = disabled.value;
      const attrs = {
        "elRef": setElRef,
        "type": "button",
        "role": "radio",
        "aria-checked": checked.value,
        "data-state": checked.value ? "checked" : "unchecked",
        "data-disabled": _disabled ? "" : void 0,
        "disabled": _disabled,
        "value": props.value(),
        onKeydown,
        onFocus,
        onClick
      };
      mergePrimitiveAttrs(attrs, [rovingFocusGroupItem.attrs(), ...extraAttrs]);
      return attrs;
    }
  };
}

const _hoisted_1 = ["name", "value", "checked", "required"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "RadioGroupBubbleInput"
  },
  __name: "RadioGroupBubbleInput",
  setup(__props) {
    const bubbleInput = useRadioContext("RadioGroupBubbleInput").bubbleInput;
    bubbleInput.isFormControl.value = true;
    let input;
    function setElRef(vNode) {
      input = vNode;
    }
    watch(bubbleInput.checked, (checked) => {
      if (!input)
        return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
      const setChecked = descriptor.set;
      if (checked && setChecked) {
        const inputEvent = new Event("input", { bubbles: bubbleInput.bubbles.value });
        const changeEvent = new Event("change", { bubbles: bubbleInput.bubbles.value });
        setChecked.call(input, checked);
        input.dispatchEvent(inputEvent);
        input.dispatchEvent(changeEvent);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("input", {
        ref: setElRef,
        type: "radio",
        "aria-hidden": "true",
        tabindex: "-1",
        name: unref(bubbleInput).name(),
        value: unref(bubbleInput).value(),
        checked: unref(bubbleInput).checked.value,
        required: unref(bubbleInput).required(),
        style: {
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }, null, 8, _hoisted_1);
    };
  }
});

const DEFAULT_RADIO_GROUP_INDICATOR_PROPS = {
  as: "span",
  forceMount: void 0
};
function useRadioGroupIndicator(props = {}) {
  const el = props.el || shallowRef();
  const setElRef = props.el ? void 0 : (value) => el.value = value;
  const context = useRadioContext("RadioGroupIndicator");
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(el, context.checked);
  return {
    isPresent,
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "data-state": context.checked.value ? "checked" : "unchecked",
        "data-disabled": context.disabled.value ? "" : void 0
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "RadioGroupIndicator",
    inheritAttrs: false
  },
  __name: "RadioGroupIndicator",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    forceMount: { type: Boolean }
  }, DEFAULT_RADIO_GROUP_INDICATOR_PROPS),
  setup(__props) {
    const props = __props;
    const radioGroupIndicator = useRadioGroupIndicator(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(radioGroupIndicator).isPresent.value ? (openBlock(), createBlock(unref(Primitive), normalizeProps(mergeProps({ key: 0 }, unref(normalizeAttrs)(unref(radioGroupIndicator).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "RadioGroupItem",
    inheritAttrs: false
  },
  __name: "RadioGroupItem",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    value: {},
    name: {},
    disabled: { type: Boolean }
  }, DEFAULT_RADIO_GROUP_ITEM_PROPS),
  setup(__props) {
    const props = __props;
    const radioGroupItem = useRadioGroupItem(convertPropsToHookProps(props, ["value", "disabled", "name"]));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(radioGroupItem).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "RadioGroup",
    inheritAttrs: false
  },
  __name: "RadioGroupRoot",
  props: /* @__PURE__ */ mergeDefaults({
    name: {},
    required: { type: Boolean },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    loop: { type: Boolean },
    value: {},
    defaultValue: {}
  }, DEFAULT_RADIO_GROUP_ROOT_PROPS),
  emits: ["update:value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const radioGroupRoot = useRadioGroupRoot(convertPropsToHookProps(
      props,
      ["value", "name", "required", "disabled", "dir"],
      () => ({
        onUpdateValue(value) {
          emit("update:value", value);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(radioGroupRoot).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_RADIO_GROUP_INDICATOR_PROPS as D, _sfc_main$3 as _, _sfc_main$2 as a, DEFAULT_RADIO_GROUP_ITEM_PROPS as b, useRadioContext as c, useRadioGroupItem as d, _sfc_main$1 as e, DEFAULT_RADIO_GROUP_ROOT_PROPS as f, provideRadioGroupContext as g, useRadioGroupContext as h, useRadioGroupRoot as i, _sfc_main as j, provideRadioContext as p, useRadioGroupIndicator as u };
//# sourceMappingURL=radio-group.mjs.map
