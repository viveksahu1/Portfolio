import { shallowRef, defineComponent, openBlock, createBlock, unref, normalizeProps, guardReactiveProps, withCtx, renderSlot, mergeDefaults, onMounted, onBeforeUnmount, createCommentVNode, watchEffect, onWatcherCleanup, mergeProps } from 'vue';
import { m as mergePrimitiveAttrs, n as normalizeAttrs, c as convertPropsToHookProps } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { u as usePresence } from './presence.mjs';
import { hideOthers } from 'aria-hidden';
import { u as useFocusGuards } from './focus-guards.mjs';
import { u as useDismissableLayer } from './dismissable-layer.mjs';
import { u as useFocusScope } from './focus-scope.mjs';
import { c as createContext, a as useRef, u as useControllableStateV2, b as useId, d as useBodyScrollLock } from './hooks.mjs';

const DEFAULT_DIALOG_ROOT_PROPS = {
  open: void 0,
  defaultOpen: void 0,
  modal: void 0
};
const [provideDialogContext, useDialogContext] = createContext("Dialog");
function useDialogRoot(props) {
  const {
    modal = true,
    defaultOpen = false
  } = props;
  const triggerRef = props.content || useRef();
  const content = props.content || shallowRef();
  const open = useControllableStateV2(props.open, props.onUpdateOpen, defaultOpen);
  provideDialogContext({
    triggerRef,
    content,
    contentId: useId(),
    titleId: useId(),
    descriptionId: useId(),
    open,
    modal,
    onOpenChange(value) {
      open.value = value;
    },
    onOpenToggle() {
      open.value = !open.value;
    }
  });
}

const DEFAULT_DIALOG_CLOSE_PROPS = {
  as: "button"
};
function useDialogClose() {
  const context = useDialogContext("DialogClose");
  function onClick(event) {
    if (event.defaultPrevented)
      return;
    context.onOpenChange(false);
  }
  return {
    attrs(extraAttrs) {
      const attrs = {
        onClick
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DialogClose"
  },
  __name: "DialogClose",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_DIALOG_CLOSE_PROPS),
  setup(__props) {
    const dialogClose = useDialogClose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(dialogClose).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const DEFAULT_DIALOG_CONTENT_PROPS = {
  forceMount: void 0
};
function useDialogContent(props) {
  const context = useDialogContext("DialogContent");
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(context.content, context.open);
  return {
    isPresent
  };
}

function useDialogContentImpl(props) {
  const context = useDialogContext("DialogContent");
  const useDialogContent = context.modal ? useDialogContentImplModal : useDialogContentImplNonModal;
  return useDialogContent(props);
}
function useDialogContentImplModal(props) {
  const context = useDialogContext("DialogContentModal");
  let clearHideOthers;
  onMounted(() => {
    if (context.content.value)
      clearHideOthers = hideOthers(context.content.value);
  });
  onBeforeUnmount(() => {
    clearHideOthers?.();
    clearHideOthers = void 0;
  });
  return useDialogContentImplShared({
    trapFocus() {
      return context.open.value;
    },
    disableOutsidePointerEvents() {
      return true;
    },
    onCloseAutoFocus(event) {
      props.onCloseAutoFocus?.(event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
      context.triggerRef.value?.focus();
    },
    onOpenAutoFocus: props.onOpenAutoFocus,
    onInteractOutside: props.onInteractOutside,
    onPointerdownOutside(event) {
      props.onPointerdownOutside?.(event);
      if (event.defaultPrevented)
        return;
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (isRightClick)
        event.preventDefault();
    },
    onFocusOutside(event) {
      props.onFocusOutside?.(event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
    },
    onEscapeKeydown: props.onEscapeKeydown
  });
}
function useDialogContentImplNonModal(props) {
  const context = useDialogContext("DialogContentNonModal");
  let hasInteractedOutsideRef = false;
  let hasPointerdownOutsideRef = false;
  return useDialogContentImplShared({
    trapFocus() {
      return false;
    },
    disableOutsidePointerEvents() {
      return false;
    },
    onCloseAutoFocus(event) {
      props.onCloseAutoFocus?.(event);
      if (!event.defaultPrevented) {
        if (!hasInteractedOutsideRef) {
          context.triggerRef.value?.focus();
        }
        event.preventDefault();
      }
      hasInteractedOutsideRef = false;
      hasPointerdownOutsideRef = false;
    },
    onOpenAutoFocus: props.onOpenAutoFocus,
    onInteractOutside(event) {
      props.onInteractOutside?.(event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef = true;
        if (event.detail.originalEvent.type === "pointerdown") {
          hasPointerdownOutsideRef = true;
        }
      }
      const target = event.target;
      const targetIsTrigger = context.triggerRef.value?.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerdownOutsideRef) {
        event.preventDefault();
      }
    },
    onPointerdownOutside: props.onPointerdownOutside,
    onFocusOutside: props.onFocusOutside,
    onEscapeKeydown: props.onEscapeKeydown
  });
}
function useDialogContentImplShared(props) {
  const context = useDialogContext("DialogContentNonModal");
  const el = props.el || shallowRef();
  const setElRef = props.el ? void 0 : (value) => {
    el.value = value;
    context.content.value = value;
  };
  useFocusGuards();
  const dismissableLayer = useDismissableLayer({
    el,
    disableOutsidePointerEvents: props.disableOutsidePointerEvents,
    onPointerdownOutside: props.onPointerdownOutside,
    onFocusOutside: props.onFocusOutside,
    onInteractOutside: props.onInteractOutside,
    onEscapeKeydown: props.onEscapeKeydown,
    onDismiss() {
      context.onOpenChange(false);
    }
  });
  const focusScope = useFocusScope({
    el,
    loop: true,
    trapped: props.trapFocus,
    onMountAutoFocus: props.onOpenAutoFocus,
    onUnmountAutoFocus: props.onCloseAutoFocus
  });
  return {
    attrs(extraAttrs = []) {
      const dismissableAttrs = {
        "elRef": setElRef,
        "role": "dialog",
        "id": context.contentId,
        "aria-describedby": context.descriptionId,
        "aria-labelledby": context.titleId,
        "data-state": context.open.value ? "open" : "closed"
      };
      return dismissableLayer.attrs([focusScope.attrs(), dismissableAttrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DialogContentImpl",
    inheritAttrs: false
  },
  __name: "DialogContentImpl",
  emits: ["openAutoFocus", "closeAutoFocus", "escapeKeydown", "pointerdownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const dialogContentImpl = useDialogContentImpl({
      onOpenAutoFocus(event) {
        emit("openAutoFocus", event);
      },
      onCloseAutoFocus(event) {
        emit("closeAutoFocus", event);
      },
      onEscapeKeydown(event) {
        emit("escapeKeydown", event);
      },
      onPointerdownOutside(event) {
        emit("pointerdownOutside", event);
      },
      onFocusOutside(event) {
        emit("focusOutside", event);
      },
      onInteractOutside(event) {
        emit("interactOutside", event);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(dialogContentImpl).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DialogContent"
  },
  __name: "DialogContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_DIALOG_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const dialogContent = useDialogContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(dialogContent).isPresent.value ? (openBlock(), createBlock(_sfc_main$6, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const DEFAULT_DIALOG_DESCRIPTION_PROPS = {
  as: "p"
};
function useDialogDescription() {
  const context = useDialogContext("DialogDescription");
  return {
    attrs(extraAttrs) {
      const attrs = {
        id: context.descriptionId
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DialogDescription",
    inheritAttrs: false
  },
  __name: "DialogDescription",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_DIALOG_DESCRIPTION_PROPS),
  setup(__props) {
    const dialogDescription = useDialogDescription();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(dialogDescription).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const DEFAULT_DIALOG_OVERLAY_PROPS = {
  forceMount: void 0
};
function useDialogOverlay(props = {}) {
  const context = useDialogContext("DialogOverlay");
  const el = props.el || shallowRef();
  const setElRef = props.el ? void 0 : (value) => el.value = value;
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(el, context.open);
  watchEffect(() => {
    if (isPresent.value) {
      onWatcherCleanup(useBodyScrollLock());
    }
  });
  return {
    isPresent,
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "data-state": isPresent.value ? "open" : "closed",
        "style": "pointer-events: auto"
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DialogOverlay"
  },
  __name: "DialogOverlay",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_DIALOG_OVERLAY_PROPS),
  setup(__props) {
    const props = __props;
    const dialogOverlay = useDialogOverlay({
      forceMount: props.forceMount
    });
    return (_ctx, _cache) => {
      return unref(dialogOverlay).isPresent.value ? (openBlock(), createBlock(unref(Primitive), normalizeProps(mergeProps({ key: 0 }, unref(normalizeAttrs)(unref(dialogOverlay).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DialogRoot",
    inheritAttrs: false
  },
  __name: "DialogRoot",
  props: /* @__PURE__ */ mergeDefaults({
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  }, DEFAULT_DIALOG_ROOT_PROPS),
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useDialogRoot(convertPropsToHookProps(
      props,
      ["open"],
      () => ({
        onUpdateOpen(open) {
          emit("update:open", open);
        }
      })
    ));
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const DEFAULT_DIALOG_TITLE_PROPS = {
  as: "h2"
};
function useDialogTitle() {
  const context = useDialogContext("DialogTitle");
  return {
    attrs(extraAttrs) {
      const attrs = {
        id: context.titleId
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "DialogTitle"
  },
  __name: "DialogTitle",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_DIALOG_TITLE_PROPS),
  setup(__props) {
    const dialogTitle = useDialogTitle();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(dialogTitle).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const DEFAULT_DIALOG_TRIGGER_PROPS = {
  as: "button"
};
function useDialogTrigger() {
  const context = useDialogContext("DialogTrigger");
  const setElRef = (value) => context.triggerRef.value = value;
  function onClick(event) {
    if (event.defaultPrevented)
      return;
    context.onOpenToggle();
  }
  return {
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "type": "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open.value || false,
        "aria-controls": context.open.value ? context.contentId : void 0,
        "data-state": context.open.value ? "open" : "closed",
        onClick
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "DialogTrigger",
    inheritAttrs: false
  },
  __name: "DialogTrigger",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_DIALOG_TRIGGER_PROPS),
  setup(__props) {
    const dialogTrigger = useDialogTrigger();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(dialogTrigger).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_DIALOG_CLOSE_PROPS as D, _sfc_main$7 as _, useDialogClose as a, useDialogContent as b, useDialogRoot as c, _sfc_main as d, _sfc_main$1 as e, _sfc_main$4 as f, _sfc_main$3 as g, useDialogContext as h, DEFAULT_DIALOG_CONTENT_PROPS as i, _sfc_main$5 as j, useDialogContentImpl as k, useDialogContentImplNonModal as l, useDialogContentImplShared as m, DEFAULT_DIALOG_DESCRIPTION_PROPS as n, useDialogDescription as o, provideDialogContext as p, DEFAULT_DIALOG_OVERLAY_PROPS as q, useDialogOverlay as r, DEFAULT_DIALOG_ROOT_PROPS as s, _sfc_main$2 as t, useDialogContentImplModal as u, DEFAULT_DIALOG_TITLE_PROPS as v, useDialogTitle as w, DEFAULT_DIALOG_TRIGGER_PROPS as x, useDialogTrigger as y };
//# sourceMappingURL=dialog.mjs.map
