import { defineComponent, openBlock, createBlock, unref, normalizeProps, mergeProps, withCtx, renderSlot, createCommentVNode, guardReactiveProps, mergeDefaults, shallowRef, onMounted, onBeforeUnmount, createElementBlock, createVNode } from 'vue';
import { u as usePopperContext, a as usePooperRoot, b as usePopperContent } from './popper.mjs';
import { m as mergePrimitiveAttrs, c as convertPropsToHookProps, n as normalizeAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { u as usePresence } from './presence.mjs';
import { hideOthers } from 'aria-hidden';
import { c as createContext, a as useRef, u as useControllableStateV2, b as useId, d as useBodyScrollLock } from './hooks.mjs';
import { u as useFocusGuards } from './focus-guards.mjs';
import { u as useFocusScope } from './focus-scope.mjs';
import { u as useDismissableLayer } from './dismissable-layer.mjs';

function usePopoverAnchor(props = {}) {
  const popperContext = usePopperContext("PopperAnchor");
  if (props.virtualRef) {
    popperContext.onAnchorChange(props.virtualRef.value);
  }
  function setElRef(v) {
    popperContext.onPostionAnchorChange(v);
  }
  return {
    isShow: !!props.virtualRef,
    attrs(extraAttrs) {
      const attrs = {
        elRef: setElRef
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  ...{
    name: "PopoverAnchor",
    inheritAttrs: false
  },
  __name: "PopoverAnchor",
  props: {
    virtualRef: {}
  },
  setup(__props) {
    const props = __props;
    const popoverAnchor = usePopoverAnchor(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return !_ctx.virtualRef ? (openBlock(), createBlock(unref(Primitive), normalizeProps(mergeProps({ key: 0 }, unref(normalizeAttrs)(unref(popoverAnchor).attrs([_ctx.$attrs])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode("", true);
    };
  }
});

const DEFAULT_POPOVER_ROOT_PROPS = {
  open: void 0,
  defaultOpen: void 0,
  modal: void 0
};
const [providePopoverContext, usePopoverContext] = createContext("Poppover");
function usePopoverRoot(props = {}) {
  const {
    defaultOpen = false,
    modal = false
  } = props;
  const triggerRef = props.triggerRef ?? useRef();
  const open = useControllableStateV2(props.open, props.onUpdateOpen, defaultOpen);
  providePopoverContext({
    triggerRef,
    contentId: useId(),
    open,
    onOpenChange(value) {
      open.value = value;
    },
    onOpenToggle() {
      open.value = !open.value;
    },
    modal
  });
  usePooperRoot();
}

const DEFAULT_POPOVER_CLOSE_PROPS = {
  as: "button"
};
function usePopoverClose() {
  const context = usePopoverContext("PopoverClose");
  function onClick(event) {
    if (event.defaultPrevented) {
      return;
    }
    context.onOpenChange(false);
  }
  return {
    attrs(extraAttrs) {
      const attrs = {
        type: "button",
        onClick
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "PopoverClose",
    inheritAttrs: false
  },
  __name: "PopoverClose",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_POPOVER_CLOSE_PROPS),
  setup(__props) {
    const popoverClose = usePopoverClose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(popoverClose).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const DEFAULT_POPOVER_CONTENT_PROPS = {
  forceMount: void 0
};
function usePopoverContent(props = {}) {
  const context = usePopoverContext("PopoverContent");
  const popperContext = usePopperContext("PopoverContent");
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(popperContext.content, context.open);
  return {
    isPresent
  };
}

const DEFAULT_POPOVER_CONTENT_IMPL_PROPS = {
  avoidCollisions: void 0,
  hideWhenDetached: void 0
};
function usePopoverContentImpl(props) {
  const context = usePopoverContext("PopoverContentImpl");
  const usePopoverContent = context.modal ? usePopoverContentModal : usePopoverContentNonModal;
  return usePopoverContent(props);
}
function usePopoverContentModal(props) {
  const context = usePopoverContext("PopoverContentModal");
  const popperContext = usePopperContext("PopoverContentModal");
  let isRightClickOutsideRef = false;
  const unlock = useBodyScrollLock();
  let clearHideOthers;
  onMounted(() => {
    if (popperContext.content.value)
      clearHideOthers = hideOthers(popperContext.content.value);
  });
  onBeforeUnmount(() => {
    unlock();
    clearHideOthers?.();
    clearHideOthers = void 0;
  });
  return usePopoverContentImplShared({
    ...props,
    onCloseAutoFocus(event) {
      if (event.defaultPrevented) {
        return;
      }
      event.preventDefault();
      if (!isRightClickOutsideRef)
        context.triggerRef.value?.focus();
    },
    onPointerdownOutside(event) {
      props.onPointerdownOutside?.(event);
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClickOutsideRef = isRightClick;
    },
    // When focus is trapped, a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    onFocusOutside(event) {
      props.onFocusOutside?.(event);
      event.preventDefault();
    }
  });
}
function usePopoverContentNonModal(props) {
  const context = usePopoverContext("PopoverContentNonModal");
  let hasInteractedOutsideRef = false;
  let hasPointerdownOutsideRef = false;
  return usePopoverContentImplShared({
    ...props,
    onCloseAutoFocus(event) {
      props.onCloseAutoFocus?.(event);
      if (!event.defaultPrevented) {
        if (!hasInteractedOutsideRef) {
          context.triggerRef.value?.focus();
        }
        event.preventDefault();
      }
      hasInteractedOutsideRef = false;
      hasPointerdownOutsideRef = false;
    },
    onInteractOutside(event) {
      props.onInteractOutside?.(event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef = true;
        if (event.detail.originalEvent.type === "pointerdown") {
          hasPointerdownOutsideRef = true;
        }
      }
      const target = event.target;
      const targetIsTrigger = context.triggerRef.value?.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerdownOutsideRef) {
        event.preventDefault();
      }
    }
  });
}
function usePopoverContentImplShared(props) {
  const context = usePopoverContext("PopoverContentImplShared");
  const popperContext = usePopperContext("PopoverContentImplShared");
  useFocusGuards();
  const focusScope = useFocusScope(
    {
      el: popperContext.content,
      loop: true,
      trapped() {
        return false;
      },
      onMountAutoFocus: props.onOpenAutoFocus,
      onUnmountAutoFocus: props.onCloseAutoFocus
    }
  );
  const dismissableLayer = useDismissableLayer({
    el: popperContext.content,
    disableOutsidePointerEvents() {
      return false;
    },
    onInteractOutside: props.onInteractOutside,
    onEscapeKeydown: props.onEscapeKeydown,
    onFocusOutside: props.onFocusOutside,
    onPointerdownOutside: props.onPointerdownOutside,
    onDismiss() {
      context.onOpenChange(false);
    }
  });
  const popperContent = usePopperContent(props);
  const style = {
    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
  };
  return {
    wrapperAttrs: popperContent.wrapperAttrs,
    attrs(extraAttrs = []) {
      const popperAttrs = {
        "id": context.contentId,
        "data-state": context.open.value ? "open" : "closed",
        "role": "dialog",
        "style": style
      };
      return popperContent.attrs([dismissableLayer.attrs(), focusScope.attrs(), popperAttrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "PopoverContentImpl",
    inheritAttrs: false
  },
  __name: "PopoverContentImpl",
  props: /* @__PURE__ */ mergeDefaults({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    dir: {}
  }, DEFAULT_POPOVER_CONTENT_IMPL_PROPS),
  emits: ["openAutoFocus", "closeAutoFocus", "escapeKeydown", "pointerdownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const popoverContentImpl = usePopoverContentImpl(convertPropsToHookProps(
      props,
      ["collisionBoundary", "dir"],
      () => ({
        onOpenAutoFocus(event) {
          emit("openAutoFocus", event);
        },
        onCloseAutoFocus(event) {
          emit("closeAutoFocus", event);
        },
        onEscapeKeydown(event) {
          emit("escapeKeydown", event);
        },
        onPointerdownOutside(event) {
          emit("pointerdownOutside", event);
        },
        onFocusOutside(event) {
          emit("focusOutside", event);
        },
        onInteractOutside(event) {
          emit("interactOutside", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", normalizeProps(guardReactiveProps(unref(popoverContentImpl).wrapperAttrs())), [
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(popoverContentImpl).attrs([_ctx.$attrs])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16)
      ], 16);
    };
  }
});

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "PopoverContent"
  },
  __name: "PopoverContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_POPOVER_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const popoverContent = usePopoverContent(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(popoverContent).isPresent.value ? (openBlock(), createBlock(_sfc_main$3, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "PopoverRoot",
    inheritAttrs: false
  },
  __name: "PopoverRoot",
  props: /* @__PURE__ */ mergeDefaults({
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  }, DEFAULT_POPOVER_ROOT_PROPS),
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    usePopoverRoot({
      open() {
        return props.open;
      },
      onUpdateOpen(open) {
        emit("update:open", open);
      },
      defaultOpen: props.defaultOpen,
      modal: props.modal
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const DEFAULT_POPOVER_TRIGGER_PROPS = {
  as: "button"
};
function usePopoverTrigger() {
  const context = usePopoverContext("PopoverTrigger");
  const popperContext = usePopperContext("PopoverTrigger");
  function setElRef(v) {
    context.triggerRef.value = v;
    popperContext.onAnchorChange(v);
  }
  function onClick(event) {
    if (event.defaultPrevented) {
      return;
    }
    context.onOpenToggle();
  }
  return {
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "type": "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open.value,
        "aria-controls": context.contentId,
        "data-state": context.open.value ? "open" : "closed",
        onClick
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "PopoverTrigger",
    inheritAttrs: false
  },
  __name: "PopoverTrigger",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_POPOVER_TRIGGER_PROPS),
  setup(__props) {
    const popoverTrigger = usePopoverTrigger();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(popoverTrigger).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_POPOVER_CLOSE_PROPS as D, _sfc_main$5 as _, usePopoverClose as a, _sfc_main$4 as b, DEFAULT_POPOVER_CONTENT_PROPS as c, usePopoverContent as d, _sfc_main$2 as e, DEFAULT_POPOVER_ROOT_PROPS as f, usePopoverContext as g, usePopoverRoot as h, _sfc_main$1 as i, DEFAULT_POPOVER_TRIGGER_PROPS as j, usePopoverTrigger as k, _sfc_main as l, providePopoverContext as p, usePopoverAnchor as u };
//# sourceMappingURL=popover.mjs.map
