import { shallowRef, watchEffect, onWatcherCleanup, watch, nextTick } from 'vue';
import { m as mergePrimitiveAttrs } from './shared.mjs';
import { i as isClient } from './avatar.mjs';

function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node) {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (!element || !element.focus)
    return;
  const previouslyFocusedElement = document.activeElement;
  element.focus({ preventScroll: true });
  if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
    element.select();
}
const focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

const AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
const EVENT_OPTIONS = { bubbles: false, cancelable: true };
const AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
function useFocusScope(props) {
  const { trapped = () => false } = props;
  const el = props.el || shallowRef();
  const setElRef = props.el ? void 0 : (value) => el.value = value;
  let lastFocusedElementRef;
  const focusScope = {
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  };
  if (isClient) {
    let handleFocusIn = function(event) {
      if (focusScope.paused || !el.value)
        return;
      const target = event.target;
      if (el.value.contains(target)) {
        lastFocusedElementRef = target;
      } else {
        focus(lastFocusedElementRef, { select: true });
      }
    }, handleFocusOut = function(event) {
      if (focusScope.paused || !el.value)
        return;
      const relatedTarget = event.relatedTarget;
      if (relatedTarget === null)
        return;
      if (!el.value.contains(relatedTarget)) {
        focus(lastFocusedElementRef, { select: true });
      }
    }, handleMutations = function() {
      const isLastFocusedElementExist = el.value?.contains(lastFocusedElementRef);
      if (!isLastFocusedElementExist) {
        focus(el.value);
      }
    };
    watchEffect(() => {
      if (!trapped())
        return;
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      const mutationObserver = new MutationObserver(handleMutations);
      if (el.value)
        mutationObserver.observe(el.value, { childList: true, subtree: true });
      onWatcherCleanup(() => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
        mutationObserver.disconnect();
      });
    });
    watch(el, async (container, _, onCleanup) => {
      if (!container)
        return;
      focusScopesStack.add(focusScope);
      await nextTick();
      const onMountAutoFocus = props.onMountAutoFocus;
      const onUnmountAutoFocus = props.onUnmountAutoFocus;
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        if (onMountAutoFocus)
          container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      onCleanup(() => {
        if (onMountAutoFocus)
          container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
        if (onUnmountAutoFocus)
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
        container.dispatchEvent(unmountEvent);
        setTimeout(() => {
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          if (onUnmountAutoFocus)
            container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      });
    });
  }
  function onKeydown(event) {
    if (!props.loop && !trapped())
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (!isTabKey || !focusedElement)
      return;
    const container = event.currentTarget;
    const [first, last] = getTabbableEdges(container);
    const hasTabbableElementsInside = first && last;
    if (!hasTabbableElementsInside) {
      if (focusedElement === container)
        event.preventDefault();
    } else {
      if (!event.shiftKey && focusedElement === last) {
        event.preventDefault();
        if (props.loop) {
          focus(first, { select: true });
        }
      } else if (event.shiftKey && focusedElement === first) {
        event.preventDefault();
        if (props.loop) {
          focus(last, { select: true });
        }
      }
    }
  }
  return {
    attrs(extraAttrs) {
      const attrs = {
        elRef: setElRef,
        tabindex: -1,
        onKeydown
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

export { useFocusScope as u };
//# sourceMappingURL=focus-scope.mjs.map
