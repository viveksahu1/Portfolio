import { onBeforeUnmount, shallowRef, watchEffect, onWatcherCleanup, onMounted, defineComponent, openBlock, createElementBlock, normalizeProps, guardReactiveProps, unref, createVNode, withCtx, renderSlot, mergeDefaults, createBlock, createCommentVNode } from 'vue';
import { a as usePooperRoot, u as usePopperContext, b as usePopperContent } from './popper.mjs';
import { u as usePresence } from './presence.mjs';
import { u as useDismissableLayer } from './dismissable-layer.mjs';
import { c as convertPropsToHookProps, n as normalizeAttrs, m as mergePrimitiveAttrs } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { c as createContext, u as useControllableStateV2, a as useRef } from './hooks.mjs';

const DEFAULT_HOVER_CARD_ROOT_PROPS = {
  open: void 0,
  defaultOpen: void 0
};
const [provideHoverCardContext, useHoverCardContext] = createContext("HoverCard");
function useHoverCardRoot(props = {}) {
  const {
    openDelay = 700,
    closeDelay = 300
  } = props;
  const open = useControllableStateV2(props.open, props.onUpdateOpen, props.defaultOpen ?? false);
  let openTimerRef = 0;
  let closeTimerRef = 0;
  const hasSelectionRef = useRef(false);
  const isPointerDownOnContentRef = useRef(false);
  onBeforeUnmount(() => {
    if (openTimerRef)
      clearTimeout(openTimerRef);
    if (closeTimerRef)
      clearTimeout(closeTimerRef);
  });
  provideHoverCardContext({
    open,
    onOpenChange(v) {
      open.value = v;
    },
    onOpen() {
      if (closeTimerRef)
        clearTimeout(closeTimerRef);
      openTimerRef = window.setTimeout(() => {
        open.value = true;
        openTimerRef = 0;
      }, openDelay);
    },
    onClose() {
      if (openTimerRef)
        clearTimeout(openTimerRef);
      if (hasSelectionRef.value || isPointerDownOnContentRef.value)
        return;
      closeTimerRef = window.setTimeout(() => {
        open.value = false;
        closeTimerRef = 0;
      }, closeDelay);
    },
    onDismiss() {
      open.value = false;
    },
    hasSelectionRef,
    isPointerDownOnContentRef
  });
  usePooperRoot();
}

const DEFAULT_HOVER_CARD_CONTENT_PROPS = {
  forceMount: void 0
};
function useHoverCardConten(props = {}) {
  const context = useHoverCardContext("HoverCardContent");
  const popperContext = usePopperContext("HoverCardContent");
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(popperContext.content, context.open);
  return {
    isPresent
  };
}

function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}

const DEFAULT_HOVER_CARD_CONTENT_IMPL_PROPS = {
  avoidCollisions: void 0,
  hideWhenDetached: void 0
};
let originalBodyUserSelect;
function useHoverCardContentImpl(props = {}) {
  const context = useHoverCardContext("HoverCardContentImpl");
  const popperContext = usePopperContext("HoverCardContentImpl");
  function onPointerenter(event) {
    if (event.defaultPrevented)
      return;
    if (event.pointerType === "touch")
      return;
    context.onOpen();
  }
  function onpointerleave(event) {
    if (event.defaultPrevented)
      return;
    if (event.pointerType === "touch")
      return;
    context.onClose();
  }
  const containSelection = shallowRef(false);
  watchEffect(() => {
    if (!containSelection.value)
      return;
    const body = document.body;
    originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
    body.style.userSelect = "none";
    body.style.webkitUserSelect = "none";
    onWatcherCleanup(() => {
      body.style.userSelect = originalBodyUserSelect;
      body.style.webkitUserSelect = originalBodyUserSelect;
    });
  });
  function handlePointerUp() {
    containSelection.value = false;
    context.isPointerDownOnContentRef.value = false;
    setTimeout(() => {
      const hasSelection = document.getSelection()?.toString() !== "";
      if (hasSelection)
        context.hasSelectionRef.value = true;
    });
  }
  onMounted(() => {
    if (!popperContext.content.value)
      return;
    document.addEventListener("pointerup", handlePointerUp);
    const tabbables = getTabbableNodes(popperContext.content.value);
    for (const tabbable of tabbables) {
      tabbable.setAttribute("tabindex", "-1");
    }
  });
  onBeforeUnmount(() => {
    document.removeEventListener("pointerup", handlePointerUp);
    context.hasSelectionRef.value = false;
    context.isPointerDownOnContentRef.value = false;
  });
  function onPointerdown(event) {
    if (event.currentTarget?.contains(event.target)) {
      containSelection.value = true;
    }
    context.hasSelectionRef.value = false;
    context.isPointerDownOnContentRef.value = true;
  }
  const dismissableLayer = useDismissableLayer({
    el: popperContext.content,
    disableOutsidePointerEvents() {
      return false;
    },
    onInteractOutside: props.onInteractOutside,
    onEscapeKeydown: props.onEscapeKeydown,
    onPointerdownOutside: props.onPointerdownOutside,
    onFocusOutside(event) {
      props.onFocusOutside?.(event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
    },
    onDismiss: context.onDismiss
  });
  const popperContent = usePopperContent(props.popperProps);
  return {
    wrapperAttrs: popperContent.wrapperAttrs,
    attrs(extraAttrs = []) {
      const popperAttrs = {
        "data-state": context.open.value ? "open" : "closed",
        onPointerenter,
        onpointerleave,
        onPointerdown
      };
      return popperContent.attrs([dismissableLayer.attrs(), popperAttrs, ...extraAttrs]);
    }
  };
}

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "HoverCardContentImpl",
    inheritAttrs: false
  },
  __name: "HoverCardContentImpl",
  props: /* @__PURE__ */ mergeDefaults({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    dir: {}
  }, DEFAULT_HOVER_CARD_CONTENT_IMPL_PROPS),
  emits: ["escapeKeydown", "pointerdownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const hoverCardContentImpl = useHoverCardContentImpl(convertPropsToHookProps(
      props,
      ["collisionBoundary", "dir"],
      () => ({
        onEscapeKeydown(event) {
          emit("escapeKeydown", event);
        },
        onPointerdownOutside(event) {
          emit("pointerdownOutside", event);
        },
        onFocusOutside(event) {
          emit("focusOutside", event);
        },
        onInteractOutside(event) {
          emit("interactOutside", event);
        }
      })
    ));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", normalizeProps(guardReactiveProps(unref(hoverCardContentImpl).wrapperAttrs())), [
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(hoverCardContentImpl).attrs([_ctx.$attrs])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16)
      ], 16);
    };
  }
});

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "HoverCardContent"
  },
  __name: "HoverCardContent",
  props: /* @__PURE__ */ mergeDefaults({
    forceMount: { type: Boolean }
  }, DEFAULT_HOVER_CARD_CONTENT_PROPS),
  setup(__props) {
    const props = __props;
    const hoverCardConten = useHoverCardConten(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return unref(hoverCardConten).isPresent.value ? (openBlock(), createBlock(_sfc_main$3, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "HoverCardRoot",
    inheritAttrs: false
  },
  __name: "HoverCardRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: false },
    openDelay: { default: 700 },
    closeDelay: { default: 300 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useHoverCardRoot(convertPropsToHookProps(
      props,
      ["open"],
      () => ({
        onUpdateOpen(open) {
          emit("update:open", open);
        }
      })
    ));
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});

const DEFAULT_HOVER_CARD_TRIGGER_PROPS = {
  as: "a"
};
function useHoverCardTrigger() {
  const context = useHoverCardContext("HoverCardTrigger");
  function onPointerenter(event) {
    if (event.defaultPrevented)
      return;
    if (event.pointerType === "touch")
      return;
    context.onOpen();
  }
  function onPointerleave(event) {
    if (event.defaultPrevented)
      return;
    if (event.pointerType === "touch")
      return;
    context.onClose();
  }
  function onFocus(event) {
    if (event.defaultPrevented)
      return;
    context.onOpen();
  }
  function onBlur(event) {
    if (event.defaultPrevented)
      return;
    context.onClose();
  }
  function onTouchstart(event) {
    if (event.defaultPrevented)
      return;
    event.preventDefault();
  }
  const popperContext = usePopperContext("HoverCardTrigger");
  const el = useRef();
  function setElRef(v) {
    el.value = v;
  }
  onMounted(() => {
    popperContext.onAnchorChange(el.value);
  });
  return {
    attrs(extraAttrs) {
      const attrs = {
        elRef: setElRef,
        onPointerenter,
        onPointerleave,
        onFocus,
        onBlur,
        onTouchstart
      };
      if (extraAttrs) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "HoverCardTrigger",
    inheritAttrs: false
  },
  __name: "HoverCardTrigger",
  props: /* @__PURE__ */ mergeDefaults({
    as: {},
    virtualRef: {}
  }, DEFAULT_HOVER_CARD_TRIGGER_PROPS),
  setup(__props) {
    const hoverCardTrigger = useHoverCardTrigger();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(hoverCardTrigger).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

export { DEFAULT_HOVER_CARD_CONTENT_PROPS as D, _sfc_main$2 as _, DEFAULT_HOVER_CARD_ROOT_PROPS as a, _sfc_main$1 as b, DEFAULT_HOVER_CARD_TRIGGER_PROPS as c, _sfc_main as d, provideHoverCardContext as p, useHoverCardContext as u };
//# sourceMappingURL=hover-card.mjs.map
