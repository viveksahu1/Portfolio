{"version":3,"file":"popper.mjs","sources":["../../../node_modules/.pnpm/@floating-ui+utils@0.2.8/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../src/popper/PopperRoot.ts","../src/popper/PopperArrow.ts","../src/popper/utils.ts","../src/popper/PopperContent.ts","../src/popper/PopperArrow.vue"],"sourcesContent":["function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import type { VirtualElement } from '@floating-ui/utils'\nimport { isElement } from '@floating-ui/utils/dom'\nimport { type Ref, shallowRef } from 'vue'\nimport { createContext } from '../hooks/index.ts'\n\nexport type Measurable = HTMLElement | VirtualElement\n\nexport interface PopperContext {\n  content: Ref<HTMLElement | undefined>\n  anchor: Ref<Measurable | undefined>\n  onAnchorChange: (newAnchor: Measurable | undefined) => void\n  onPostionAnchorChange: (newAnchor: Measurable | undefined) => void\n}\n\nexport const [providePopperContext, usePopperContext] = createContext<PopperContext>('Popper')\n\nexport interface UsePooperRootProps {\n  anchor?: Ref<Measurable | undefined>\n  content?: Ref<HTMLElement | undefined>\n}\n\nexport function usePooperRoot(props?: UsePooperRootProps) {\n  const content = props?.content ?? shallowRef<HTMLElement>()\n  const anchor = props?.anchor ?? shallowRef<Measurable>()\n  let anchorRef: Measurable | undefined\n\n  providePopperContext({\n    content,\n    anchor,\n    onAnchorChange(node) {\n      if (props?.anchor != null)\n        return\n      // Backwards-compatibility for passing a virtual element to `reference`\n      // after it has set the DOM reference.\n      if (\n        isElement(anchorRef) || anchorRef == null\n        // Don't allow setpositionReference.valueting virtual elements using the old technique back to\n        // `null` to support `positionReference` + an unstable `reference`\n        // callback ref.\n        || (node != null && !isElement(node))\n      ) {\n        anchor.value = node\n        anchorRef = node\n      }\n    },\n    onPostionAnchorChange(node) {\n      if (props?.anchor != null)\n        return\n\n      const computedPositionReference = isElement(node)\n        ? {\n            getBoundingClientRect: () => node.getBoundingClientRect(),\n            contextElement: node,\n          }\n        : node\n      // Store the positionReference in state if the DOM reference is specified externally via the\n      // `elements.reference` option. This ensures that it won't be overridden on future renders.\n      // positionReference.value = computedPositionReference\n      anchor.value = computedPositionReference\n      anchorRef = computedPositionReference\n    },\n  })\n}\n","import type { ArrowProps } from '../arrow/index.ts'\nimport type { PrimitiveDefaultProps } from '../shared/index.ts'\nimport type { Side } from './PopperContent.ts'\n\nexport interface PopperArrowProps extends ArrowProps {\n}\n\nexport const DEFAULT_ARROW_PROPS = {\n  as: 'svg',\n  width: 10,\n  height: 5,\n} satisfies PrimitiveDefaultProps<PopperArrowProps>\n\nexport const OPPOSITE_SIDE: Record<Side, Side> = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n}\n","import type { Middleware, Placement, Side } from '@floating-ui/vue'\nimport type { Align } from './PopperContent'\n\nexport function isNotNull<T>(value: T | null | undefined): value is T {\n  return value != null\n}\n\nexport function transformOrigin(options: {\n  arrowWidth: number\n  arrowHeight: number\n}): Middleware {\n  return {\n    name: 'transformOrigin',\n    options,\n    fn(data) {\n      const { placement, rects, middlewareData } = data\n\n      const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0\n      const isArrowHidden = cannotCenterArrow\n      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth\n      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight\n\n      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement)\n      const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[\n        placedAlign\n      ]\n\n      const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2\n      const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2\n\n      let x = ''\n      let y = ''\n\n      if (placedSide === 'bottom') {\n        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`\n        y = `${-arrowHeight}px`\n      }\n      else if (placedSide === 'top') {\n        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`\n        y = `${rects.floating.height + arrowHeight}px`\n      }\n      else if (placedSide === 'right') {\n        x = `${-arrowHeight}px`\n        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`\n      }\n      else if (placedSide === 'left') {\n        x = `${rects.floating.width + arrowHeight}px`\n        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`\n      }\n      return { data: { x, y } }\n    },\n  }\n}\n\nexport function getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = 'center'] = placement.split('-')\n  return [side as Side, align as Align] as const\n}\n","import type { MaybeRefOrGetter, Ref } from 'vue'\nimport type { Direction } from '../direction/index.ts'\nimport { shallowRef, toValue, watch, watchEffect } from 'vue'\n\nimport {\n  autoUpdate,\n  flip,\n  arrow as floatingUIarrow,\n  hide,\n  limitShift,\n  offset,\n  type Placement,\n  shift,\n  size,\n  useFloating,\n  type UseFloatingCofnig,\n} from '../floating/index.ts'\nimport { createContext, useSize } from '../hooks/index.ts'\nimport { type EmitsToHookProps, type IAttrsData, mergePrimitiveAttrs, type PrimitiveDefaultProps, type RadixPrimitiveGetAttrs, type RadixPrimitiveReturns } from '../shared/index.ts'\nimport { usePopperContext } from './PopperRoot.ts'\nimport { getSideAndAlignFromPlacement, isNotNull, transformOrigin } from './utils.ts'\n\nexport interface PopperContentProps {\n  side?: Side\n  sideOffset?: number\n  align?: Align\n  alignOffset?: number\n  arrowPadding?: number\n  avoidCollisions?: boolean\n  collisionBoundary?: Boundary | Boundary[]\n  collisionPadding?: number | Partial<Record<Side, number>>\n  sticky?: 'partial' | 'always'\n  hideWhenDetached?: boolean\n  updatePositionStrategy?: 'optimized' | 'always'\n  dir?: Direction\n}\n\nexport const DEFAULT_POPPER_CONTENT_PROPS = {\n  avoidCollisions: undefined,\n  hideWhenDetached: undefined,\n} satisfies PrimitiveDefaultProps<PopperContentProps>\n\nexport type PopperContentEmits = {\n  placed: []\n}\n\ntype Boundary = Element | undefined\n\nexport const SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const\nexport const ALIGN_OPTIONS = ['start', 'center', 'end'] as const\n\nexport type Side = (typeof SIDE_OPTIONS)[number]\nexport type Align = (typeof ALIGN_OPTIONS)[number]\n\nexport interface PopperContentContext {\n  placedSide: Ref<Side>\n  onArrowChange: (newArrow: HTMLSpanElement | undefined) => void\n  arrowX: () => number | undefined\n  arrowY: () => number | undefined\n  shouldHideArrow: () => boolean\n}\n\nexport const [provideContentContext, useContentContext] = createContext<PopperContentContext>('PopperContent')\n\nexport interface UsePopperContentProps extends EmitsToHookProps<PopperContentEmits> {\n  side?: Side\n  sideOffset?: number\n  align?: Align\n  alignOffset?: number\n  arrowPadding?: number\n  avoidCollisions?: boolean\n  collisionBoundary?: () => Boundary | Boundary[]\n  collisionPadding?: number | Partial<Record<Side, number>>\n  sticky?: 'partial' | 'always'\n  hideWhenDetached?: boolean\n  updatePositionStrategy?: 'optimized' | 'always'\n  dir?: MaybeRefOrGetter<Direction | undefined>\n}\n\nexport function usePopperContent(props: UsePopperContentProps = {}): RadixPrimitiveReturns<{\n  wrapperAttrs: () => IAttrsData\n  attrs: RadixPrimitiveGetAttrs\n}> {\n  const {\n    side = 'bottom',\n    sideOffset = 0,\n    align = 'center',\n    alignOffset = 0,\n    arrowPadding = 0,\n    avoidCollisions = true,\n    collisionBoundary = () => [],\n    collisionPadding: propCollisionPadding = 0,\n    sticky = 'partial',\n    hideWhenDetached = false,\n    updatePositionStrategy = 'optimized',\n  } = props\n\n  const context = usePopperContext('PopperContent')\n\n  function setTemplateContent(value: HTMLElement | undefined) {\n    context.content.value = value\n  }\n\n  const floatingEl = shallowRef<HTMLElement>()\n\n  function setTemplateFloating(value: any) {\n    floatingEl.value = value\n  }\n\n  const arrow = shallowRef<HTMLSpanElement>()\n\n  const arrowSize = useSize(arrow)\n\n  function getDetectOverflowOptions() {\n    const collisionPadding = typeof propCollisionPadding === 'number'\n      ? propCollisionPadding\n      : { top: 0, right: 0, bottom: 0, left: 0, ...propCollisionPadding }\n\n    const _collisionBoundary = collisionBoundary()\n    const boundary = Array.isArray(_collisionBoundary) ? _collisionBoundary : [_collisionBoundary]\n    const hasExplicitBoundaries = boundary.length > 0\n\n    return {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries,\n    }\n  }\n\n  function floatingConfig(): UseFloatingCofnig {\n    const detectOverflowOptions = getDetectOverflowOptions()\n\n    const placement = (side + (align !== 'center' ? `-${align}` : '')) as Placement\n    const arrowHeight = arrowSize.value?.height || 0\n    const arrowWidth = arrowSize.value?.width || 0\n\n    const middleware: UseFloatingCofnig['middleware'] = [\n      offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n    ]\n\n    if (avoidCollisions) {\n      middleware.push(\n        shift({\n          mainAxis: true,\n          crossAxis: false,\n          limiter: sticky === 'partial' ? limitShift() : undefined,\n          ...detectOverflowOptions,\n        }),\n        flip(detectOverflowOptions),\n      )\n    }\n\n    middleware.push(size({\n      ...detectOverflowOptions,\n      apply: (state) => {\n        const { width: anchorWidth, height: anchorHeight } = state.rects.reference\n        const contentStyle = state.elements.floating.style\n        contentStyle.setProperty('--radix-popper-available-width', `${state.availableWidth}px`)\n        contentStyle.setProperty('--radix-popper-available-height', `${state.availableHeight}px`)\n        contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`)\n        contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`)\n      },\n    }))\n\n    if (arrow.value) {\n      middleware.push(floatingUIarrow({ element: arrow, padding: arrowPadding }))\n    }\n\n    middleware.push(transformOrigin({ arrowWidth, arrowHeight }))\n\n    if (hideWhenDetached) {\n      middleware.push(hide({ strategy: 'referenceHidden', ...detectOverflowOptions }))\n    }\n\n    return {\n      strategy: 'fixed',\n      placement,\n      middleware,\n    }\n  }\n\n  const { floatingStyles, placement, isPositioned, middlewareData } = useFloating(\n    {\n      elements: {\n        floatingEl,\n        referenceEl: context.anchor,\n      },\n      whileElementsMounted(reference, floating, update) {\n        return autoUpdate(reference, floating, update, {\n          animationFrame: updatePositionStrategy === 'always',\n        })\n      },\n    },\n    floatingConfig,\n  )\n\n  const placedSide = shallowRef<Side>('bottom')\n  const placedAlign = shallowRef<Align>('center')\n\n  watchEffect(() => {\n    const [side, align] = getSideAndAlignFromPlacement(placement.value)\n    placedSide.value = side\n    placedAlign.value = align\n  })\n\n  watchEffect(() => {\n    if (isPositioned.value) {\n      props.onPlaced?.()\n    }\n  }, { flush: 'post' })\n\n  // TODO: z-index\n  const contentZIndex = shallowRef('')\n\n  watch(context.content, (contentVal) => {\n    if (contentVal) {\n      contentZIndex.value = window.getComputedStyle(contentVal).zIndex\n    }\n  })\n\n  provideContentContext({\n    placedSide,\n    onArrowChange(newArrow) {\n      arrow.value = newArrow\n    },\n    arrowX() {\n      return middlewareData.value.arrow?.x ?? undefined\n    },\n    arrowY() {\n      return middlewareData.value.arrow?.y ?? undefined\n    },\n    shouldHideArrow() {\n      return middlewareData.value.arrow?.centerOffset !== 0\n    },\n  })\n\n  return {\n    wrapperAttrs() {\n      const _middlewareData = middlewareData.value\n      const _floatingStyles = floatingStyles.value\n      const attrs = {\n        'ref': setTemplateFloating,\n        'data-radix-popper-content-wrapper': '',\n        'style': {\n          ..._floatingStyles,\n          'transform': isPositioned.value ? _floatingStyles.transform : 'translate(0, -200%)', // keep off the page when measuring\n          'minWidth': 'max-content',\n          'zIndex': contentZIndex.value,\n          '--radix-popper-transform-origin': [\n            _middlewareData.transformOrigin?.x,\n            _middlewareData.transformOrigin?.y,\n          ].join(' '),\n\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...(_middlewareData.hide?.referenceHidden && {\n            visibility: 'hidden',\n            pointerEvents: 'none',\n          }),\n        },\n        'dir': toValue(props.dir),\n      }\n\n      return attrs\n    },\n    attrs(extraAttrs) {\n      const attrs = {\n        'elRef': setTemplateContent,\n        'data-side': placedSide.value,\n        'data-align': placedAlign.value,\n        'style': {\n          // if the PopperContent hasn't been placed yet (not all measurements done)\n          // we prevent animations so that users's animation don't kick in too early referring wrong sides\n          animation: !isPositioned.value ? 'none' : undefined,\n        },\n      }\n\n      if (extraAttrs && extraAttrs.length > 0) {\n        mergePrimitiveAttrs(attrs, extraAttrs)\n      }\n\n      return attrs\n    },\n  }\n}\n","<script setup lang=\"ts\">\nimport { Primitive } from '../primitive/index.ts'\nimport { DEFAULT_ARROW_PROPS, OPPOSITE_SIDE, type PopperArrowProps } from './PopperArrow.ts'\nimport { useContentContext } from './PopperContent.ts'\n\ndefineOptions({\n  name: 'PopperArrow',\n  inheritAttrs: false,\n})\n\nwithDefaults(defineProps<PopperArrowProps>(), DEFAULT_ARROW_PROPS)\n\nconst contentContext = useContentContext('PopperArrow')\n</script>\n\n<template>\n  <span\n    :ref=\"(contentContext.onArrowChange as any)\"\n    :style=\"{\n      position: 'absolute',\n      left: contentContext.arrowX() ? `${contentContext.arrowX()}px` : undefined,\n      top: contentContext.arrowY() ? `${contentContext.arrowY()}px` : undefined,\n      [OPPOSITE_SIDE[contentContext.placedSide.value]]: 0,\n      transformOrigin: {\n        top: '',\n        right: '0 0',\n        bottom: 'center 0',\n        left: '100% 0',\n      }[contentContext.placedSide.value],\n      transform: {\n        top: 'translateY(100%)',\n        right: 'translateY(50%) rotate(90deg) translateX(-50%)',\n        bottom: `rotate(180deg)`,\n        left: 'translateY(50%) rotate(-90deg) translateX(50%)',\n      }[contentContext.placedSide.value],\n      visibility: contentContext.shouldHideArrow() ? 'hidden' : undefined,\n    }\"\n  >\n    <Primitive\n      :as=\"as\"\n      v-bind=\"$attrs\"\n      :width=\"width\"\n      :height=\"height\"\n      :viewBox=\"as === 'template' ? undefined : '0 0 30 10'\"\n      :preserveAspectRatio=\"as === 'template' ? undefined : 'none'\"\n      style=\"display: block\"\n    >\n      <slot><polygon points=\"0,0 30,0 15,10\" /></slot>\n    </Primitive>\n  </span>\n</template>\n"],"names":["arrow","placement","floatingUIarrow","side","align"],"mappings":"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","x_google_ignoreList":[0]}