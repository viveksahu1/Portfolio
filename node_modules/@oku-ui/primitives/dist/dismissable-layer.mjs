import { watch, onWatcherCleanup, nextTick, shallowRef, computed, shallowReactive, onMounted, onBeforeUnmount } from 'vue';
import { i as isClient } from './avatar.mjs';
import { e as useEscapeKeydown, a as useRef } from './hooks.mjs';
import { m as mergePrimitiveAttrs } from './shared.mjs';

const POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
const FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
function usePointerdownOutside(onPointerDownOutside, node) {
  let isPointerInsideDOMTree = false;
  let handleClick = () => {
  };
  const ret = {
    // ensures we check React component tree (not just DOM tree)
    onPointerdownCapture: () => {
      isPointerInsideDOMTree = true;
    }
  };
  if (!isClient) {
    return ret;
  }
  watch(node, (nodeVal) => {
    if (!nodeVal)
      return;
    const ownerDocument = nodeVal.ownerDocument;
    async function handlePointerDown(event) {
      if (!node.value)
        return;
      const target = event.target;
      isPointerInsideDOMTree = isInsideDOMTree(node.value, target);
      if (target && !isPointerInsideDOMTree) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, onPointerDownOutside, eventDetail);
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClick);
          handleClick = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClick, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClick);
      }
      isPointerInsideDOMTree = false;
    }
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    onWatcherCleanup(() => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClick);
    });
  });
  return ret;
}
function useFocusOutside(onFocusOutside, node) {
  let isFocusInsideDOMTree = false;
  const ret = {
    onFocusCapture: () => {
      isFocusInsideDOMTree = true;
    },
    onBlurCapture: () => {
      isFocusInsideDOMTree = false;
    }
  };
  if (!isClient) {
    return ret;
  }
  const handleFocus = async (event) => {
    await nextTick();
    if (!node.value)
      return;
    isFocusInsideDOMTree = isInsideDOMTree(node.value, event.target);
    if (event.target && !isFocusInsideDOMTree) {
      const eventDetail = { originalEvent: event };
      handleAndDispatchCustomEvent(FOCUS_OUTSIDE, onFocusOutside, eventDetail);
    }
  };
  watch(node, (nodeVal) => {
    if (!nodeVal)
      return;
    const ownerDocument = nodeVal.ownerDocument;
    ownerDocument.addEventListener("focusin", handleFocus);
    onWatcherCleanup(() => {
      ownerDocument.removeEventListener("focusin", handleFocus);
    });
  });
  return ret;
}
function isInsideDOMTree(mainLayer, targetElement) {
  if (!mainLayer)
    return false;
  const targetLayer = targetElement.closest("[data-dismissable-layer]");
  if (!targetLayer)
    return false;
  if (mainLayer === targetLayer)
    return true;
  const layerList = Array.from(mainLayer.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  if (layerList.indexOf(mainLayer) < layerList.indexOf(targetLayer))
    return true;
  return false;
}
function handleAndDispatchCustomEvent(name, handler, detail) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  target.dispatchEvent(event);
}

const context = {
  layers: shallowReactive(/* @__PURE__ */ new Set()),
  layersWithOutsidePointerEventsDisabled: shallowReactive(/* @__PURE__ */ new Set()),
  branches: shallowReactive(/* @__PURE__ */ new Set())
};
let originalBodyPointerEvents;
function useDismissableLayer(props = {}) {
  const { disableOutsidePointerEvents = () => false } = props;
  const el = props.el || shallowRef();
  const setElRef = props.el ? void 0 : (value) => el.value = value;
  const ownerDocument = () => el.value?.ownerDocument ?? globalThis?.document;
  const index = computed(() => el.value ? Array.from(context.layers).indexOf(el.value) : -1);
  const isBodyPointerEventsDisabled = computed(() => context.layersWithOutsidePointerEventsDisabled.size > 0);
  const isPointerEventsEnabled = computed(() => {
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = highestLayerWithOutsidePointerEventsDisabled ? layers.indexOf(highestLayerWithOutsidePointerEventsDisabled) : -1;
    return index.value >= highestLayerWithOutsidePointerEventsDisabledIndex;
  });
  usePointerdownOutside((event) => {
    if (!isPointerEventsEnabled.value)
      return;
    const target = event.target;
    const isPointerdownOnBranch = [...context.branches].some((branch) => branch.contains(target));
    if (isPointerdownOnBranch)
      return;
    props.onPointerdownOutside?.(event);
    props.onInteractOutside?.(event);
    if (!event.defaultPrevented) {
      props.onDismiss?.();
    }
  }, el);
  useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
    if (isFocusInBranch)
      return;
    props.onFocusOutside?.(event);
    props.onInteractOutside?.(event);
    if (!event.defaultPrevented)
      props.onDismiss?.();
  }, el);
  useEscapeKeydown((event) => {
    const isHighestLayer = index.value === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    props.onEscapeKeydown?.(event);
    if (!event.defaultPrevented) {
      event.preventDefault();
      props.onDismiss?.();
    }
  }, ownerDocument);
  watch(el, (nodeVal) => {
    if (!nodeVal)
      return;
    const ownerDocumentVal = ownerDocument();
    const _disableOutsidePointerEvents = disableOutsidePointerEvents();
    if (_disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        originalBodyPointerEvents = ownerDocumentVal.body.style.pointerEvents;
        ownerDocumentVal.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(nodeVal);
    }
    context.layers.add(nodeVal);
    onWatcherCleanup(() => {
      if (_disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
        if (!originalBodyPointerEvents) {
          const syles = ownerDocumentVal.body.style;
          syles.removeProperty("pointer-events");
        } else {
          ownerDocumentVal.body.style.pointerEvents = originalBodyPointerEvents;
        }
      }
      context.layers.delete(nodeVal);
      context.layersWithOutsidePointerEventsDisabled.delete(nodeVal);
    });
  });
  return {
    attrs(extraAttrs) {
      const attrs = {
        "elRef": setElRef,
        "data-dismissable-layer": true,
        "style": {
          pointerEvents: isBodyPointerEventsDisabled.value ? isPointerEventsEnabled.value ? "auto" : "none" : void 0
        }
      };
      if (extraAttrs && extraAttrs.length > 0)
        mergePrimitiveAttrs(attrs, extraAttrs);
      return attrs;
    }
  };
}

function useDismissableLayerBranch(props = {}) {
  const elRef = props.elRef ?? useRef();
  const setElRef = props.elRef ? void 0 : (value) => elRef.value = value;
  onMounted(() => {
    context.branches.add(elRef.value);
  });
  onBeforeUnmount(() => {
    context.branches.delete(elRef.value);
  });
  return {
    attrs(extraAttrs) {
      const attrs = {
        elRef: setElRef
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

export { useDismissableLayerBranch as a, useDismissableLayer as u };
//# sourceMappingURL=dismissable-layer.mjs.map
