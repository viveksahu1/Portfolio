import { toValue, watchEffect, watch, onWatcherCleanup, computed } from 'vue';
import { g as useStateMachine } from './hooks.mjs';

function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function usePresence(elRef, present, onChange) {
  let styles = {};
  let prevAnimationName = "none";
  const initialState = toValue(present) ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  watchEffect(() => {
    const currentAnimationName = getAnimationName(styles);
    prevAnimationName = state.value === "mounted" ? currentAnimationName : "none";
  });
  watch(present, async (present2, wasPresent) => {
    onChange?.(present2);
    const currentAnimationName = getAnimationName(styles);
    if (present2) {
      send("MOUNT");
    } else if (currentAnimationName === "none" || styles?.display === "none") {
      send("UNMOUNT");
    } else {
      const isAnimating = prevAnimationName !== currentAnimationName;
      if (wasPresent && isAnimating) {
        send("ANIMATION_OUT");
      } else {
        send("UNMOUNT");
      }
    }
  }, {
    flush: "post"
  });
  async function handleAnimationEnd(event) {
    const currentAnimationName = getAnimationName(styles);
    const isCurrentAnimation = currentAnimationName.includes(
      event.animationName
    );
    if (event.target === elRef.value && isCurrentAnimation) {
      send("ANIMATION_END");
    }
  }
  function handleAnimationStart(event) {
    if (event.target === elRef.value)
      prevAnimationName = getAnimationName(styles);
  }
  watch(elRef, (node) => {
    if (node) {
      styles = getComputedStyle(node);
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      onWatcherCleanup(() => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      });
    } else {
      send("ANIMATION_END");
    }
  });
  return computed(() => state.value === "mounted" || state.value === "unmountSuspended");
}

export { usePresence as u };
//# sourceMappingURL=presence.mjs.map
