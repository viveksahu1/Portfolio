import { shallowRef, defineComponent, openBlock, createBlock, unref, normalizeProps, guardReactiveProps, withCtx, renderSlot, mergeDefaults, onMounted, onBeforeUnmount, computed, watchEffect, onWatcherCleanup, watch, toValue, createElementBlock, Fragment, Teleport, normalizeStyle, toDisplayString, createCommentVNode, createVNode, mergeProps } from 'vue';
import { m as mergePrimitiveAttrs, n as normalizeAttrs, f as focusFirst, c as convertPropsToHookProps } from './shared.mjs';
import { P as Primitive } from './primitive.mjs';
import { u as usePresence } from './presence.mjs';
import { c as createContext, u as useControllableStateV2, a as useRef } from './hooks.mjs';
import { V as VISUALLY_HIDDEN_STYLE } from './visually-hidden.mjs';
import { c as createCollection, D as DATA_COLLECTION_ITEM } from './collection.mjs';
import { a as useDismissableLayerBranch, u as useDismissableLayer } from './dismissable-layer.mjs';
import { i as isClient } from './avatar.mjs';

const DEFAULT_TOAST_ROOT_PROPS = {
  open: void 0,
  defaultOpen: void 0,
  forceMount: void 0
};
const [provideToastRootContext, useToastRootContext] = createContext("Toast");
function useToastRoot(props = {}) {
  const { defaultOpen = true } = props;
  const el = shallowRef();
  const open = useControllableStateV2(
    props.open,
    props.onUpdateOpen,
    defaultOpen
  );
  const isPresent = props.forceMount ? shallowRef(true) : usePresence(el, open);
  let _onClose = () => {
  };
  provideToastRootContext({
    el,
    open,
    onChangeOpen(v) {
      open.value = v;
    },
    onClose: () => _onClose(),
    setOnClose(onClose) {
      _onClose = onClose;
    }
  });
  return {
    isPresent
  };
}
const TOAST_SWIPE_START = "toast.swipeStart";
const TOAST_SWIPE_MOVE = "toast.swipeMove";
const TOAST_SWIPE_CANCEL = "toast.swipeCancel";
const TOAST_SWIPE_END = "toast.swipeEnd";

const DEFAULT_TOAST_CLOSE_PROPS = {
  as: "button"
};
function useToastClose() {
  const interactiveContext = useToastRootContext("ToastClose");
  function onClick(event) {
    if (event.defaultPrevented) {
      return;
    }
    interactiveContext.onClose();
  }
  return {
    attrs(extraAttrs) {
      const attrs = {
        "type": "button",
        "data-radix-toast-announce-exclude": "",
        onClick
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ToastClose",
    inheritAttrs: false
  },
  __name: "ToastClose",
  props: /* @__PURE__ */ mergeDefaults({
    as: {}
  }, DEFAULT_TOAST_CLOSE_PROPS),
  setup(__props) {
    const toastClose = useToastClose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(toastClose).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

const [provideToastProviderContext, useToastProviderContext] = createContext("Toast");
function useToastProvider(props = {}) {
  const {
    label = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50
  } = props;
  const viewport = shallowRef();
  const toastCount = shallowRef(0);
  const isFocusedToastEscapeKeyDownRef = useRef(false);
  const isClosePausedRef = useRef(false);
  provideToastProviderContext({
    label,
    duration,
    swipeDirection: shallowRef(swipeDirection),
    swipeThreshold,
    toastCount,
    viewport,
    onToastAdd() {
      toastCount.value += 1;
    },
    onToastRemove() {
      toastCount.value -= 1;
    },
    isFocusedToastEscapeKeyDownRef,
    isClosePausedRef
  });
}

function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container?.childNodes || []);
  for (const node of childNodes) {
    if (node.nodeType === node.TEXT_NODE && node.textContent)
      textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText)
            textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  }
  return textContent;
}
function handleAndDispatchCustomEvent(name, handler, detail) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler)
    currentTarget.addEventListener(name, handler, { once: true });
  currentTarget.dispatchEvent(event);
}
function isDeltaInDirection(delta, direction, threshold = 0) {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right")
    return isDeltaX && deltaX > threshold;
  return !isDeltaX && deltaY > threshold;
}
function useNextFrame(callback = () => {
}) {
  let raf1 = 0;
  let raf2 = 0;
  raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(callback));
  return () => {
    window.cancelAnimationFrame(raf1);
    window.cancelAnimationFrame(raf2);
  };
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node) {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) {
    nodes.push(walker.currentNode);
  }
  return nodes;
}

function useToastAnnounce() {
  const context = useToastProviderContext("ToastAnnounce");
  const renderAnnounceText = shallowRef(false);
  const isAnnounced = shallowRef(false);
  let timer = 0;
  let clear;
  onMounted(() => {
    timer = window.setTimeout(() => {
      isAnnounced.value = true;
      timer = 0;
    }, 1e3);
    clear = useNextFrame(() => {
      renderAnnounceText.value = true;
    });
  });
  onBeforeUnmount(() => {
    if (timer)
      window.clearTimeout(timer);
    clear?.();
  });
  return {
    isAnnounced,
    renderAnnounceText,
    label: context.label
  };
}

const [Collection, useCollection] = createCollection("Toast");

const VIEWPORT_PAUSE = "toast.viewportPause";
const VIEWPORT_RESUME = "toast.viewportResume";
function useToastViewport(props = {}) {
  const {
    hotkey = ["F8"],
    label = "Notifications ({hotkey})"
  } = props;
  const context = useToastProviderContext("ToastViewport");
  const wrapperRef = useRef();
  function setWrapperEl(v) {
    wrapperRef.value = v;
  }
  let headFocusProxyRef;
  function setHeadFocusProxyEl(v) {
    headFocusProxyRef = v;
  }
  let tailFocusProxyRef;
  function setTailFocusProxyRef(v) {
    tailFocusProxyRef = v;
  }
  const viewportRef = useRef();
  const collеctionContext = Collection.provideCollectionContext(viewportRef);
  const getItems = useCollection(collеctionContext);
  function setViewportEl(v) {
    viewportRef.value = v;
    context.viewport.value = v;
  }
  const ariaLabel = label.replace("{hotkey}", hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, ""));
  const hasToasts = computed(() => context.toastCount.value > 0);
  if (isClient) {
    let handlePause = function() {
      if (!context.isClosePausedRef.value) {
        const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
        viewportRef.value?.dispatchEvent(pauseEvent);
        context.isClosePausedRef.value = true;
      }
    }, handleResume = function() {
      if (context.isClosePausedRef.value) {
        const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
        viewportRef.value?.dispatchEvent(resumeEvent);
        context.isClosePausedRef.value = false;
      }
    }, handleFocusOutResume = function(event) {
      const isFocusMovingOutside = !wrapperRef.value?.contains(event.relatedTarget);
      if (isFocusMovingOutside)
        handleResume();
    }, handlePointerLeaveResume = function() {
      const isFocusInside = wrapperRef.value?.contains(document.activeElement);
      if (!isFocusInside)
        handleResume();
    };
    watchEffect(() => {
      const wrapper = wrapperRef.value;
      if (!hasToasts.value || !wrapper || !viewportRef.value)
        return;
      wrapper.addEventListener("focusin", handlePause);
      wrapper.addEventListener("focusout", handleFocusOutResume);
      wrapper.addEventListener("pointermove", handlePause);
      wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
      window.addEventListener("blur", handlePause);
      window.addEventListener("focus", handleResume);
      onWatcherCleanup(() => {
        wrapper.removeEventListener("focusin", handlePause);
        wrapper.removeEventListener("focusout", handleFocusOutResume);
        wrapper.removeEventListener("pointermove", handlePause);
        wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
        window.removeEventListener("blur", handlePause);
        window.removeEventListener("focus", handleResume);
      });
    });
  }
  function getSortedTabbableCandidates({ tabbingDirection }) {
    const toastItems = getItems();
    const tabbableCandidates = [];
    for (const toastItem of toastItems) {
      const toastNode = toastItem;
      const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
      tabbableCandidates.push(tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse());
    }
    return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
  }
  function handleViewportKeydown(event) {
    const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
    const isTabKey = event.key === "Tab" && !isMetaKey;
    if (!isTabKey)
      return;
    const focusedElement = document.activeElement;
    const isTabbingBackwards = event.shiftKey;
    const targetIsViewport = event.target === viewportRef.value;
    if (targetIsViewport && isTabbingBackwards) {
      headFocusProxyRef?.focus();
      return;
    }
    const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
    const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
    const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
    if (focusFirst(sortedCandidates.slice(index + 1))) {
      event.preventDefault();
    } else {
      if (isTabbingBackwards)
        headFocusProxyRef?.focus();
      else
        tailFocusProxyRef?.focus();
    }
  }
  function handleDocumentKeydown(event) {
    const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);
    if (isHotkeyPressed)
      viewportRef.value?.focus();
  }
  onMounted(() => {
    viewportRef.value?.addEventListener("keydown", handleViewportKeydown);
    document.addEventListener("keydown", handleDocumentKeydown);
  });
  onBeforeUnmount(() => {
    viewportRef.value?.removeEventListener("keydown", handleViewportKeydown);
    document.removeEventListener("keydown", handleDocumentKeydown);
  });
  function useFocusProxyHandler(cb) {
    return (event) => {
      const prevFocusedElement = event.relatedTarget;
      const isFocusFromOutsideViewport = !context.viewport.value?.contains(prevFocusedElement);
      if (!isFocusFromOutsideViewport)
        return;
      cb();
    };
  }
  const handleHeadFocusProxyFocus = useFocusProxyHandler(() => {
    const tabbableCandidates = getSortedTabbableCandidates({
      tabbingDirection: "forwards"
    });
    focusFirst(tabbableCandidates);
  });
  const handleTailFocusProxyFocus = useFocusProxyHandler(() => {
    const tabbableCandidates = getSortedTabbableCandidates({
      tabbingDirection: "backwards"
    });
    focusFirst(tabbableCandidates);
  });
  const dismissableLayerBranch = useDismissableLayerBranch({ elRef: wrapperRef });
  const headFocusProxyAttrs = {
    "ref": setHeadFocusProxyEl,
    "aria-hidden": true,
    "tabindex": 0,
    "style": {
      ...VISUALLY_HIDDEN_STYLE,
      position: "fixed"
    },
    "onFocus": handleHeadFocusProxyFocus
  };
  const tailFocusProxyAttrs = {
    "ref": setTailFocusProxyRef,
    "aria-hidden": true,
    "tabindex": 0,
    "style": {
      ...VISUALLY_HIDDEN_STYLE,
      position: "fixed"
    },
    "onFocus": handleTailFocusProxyFocus
  };
  return {
    isShowFocusProxy: hasToasts,
    wrapperAttrs() {
      const attrs = {
        "ref": setWrapperEl,
        "role": "region",
        "aria-label": ariaLabel,
        "tabindex": -1,
        "style": {
          // incase list has size when empty (e.g. padding), we remove pointer events so
          // it doesn't prevent interactions with page elements that it overlays
          pointerEvents: hasToasts.value ? void 0 : "none"
        }
      };
      return dismissableLayerBranch.attrs([attrs]);
    },
    headFocusProxy() {
      return headFocusProxyAttrs;
    },
    tailFocusProxy() {
      return tailFocusProxyAttrs;
    },
    attrs(extraAttrs) {
      const attrs = {
        elRef: setViewportEl,
        tabindex: -1
      };
      if (extraAttrs && extraAttrs.length > 0) {
        mergePrimitiveAttrs(attrs, extraAttrs);
      }
      return attrs;
    }
  };
}

function useToastRootImpl(props) {
  const {
    type = "foreground"
  } = props;
  const context = useToastProviderContext("ToastRootImpl");
  const contextToastRoot = useToastRootContext("ToastRootImpl");
  function setElRef(node) {
    contextToastRoot.el.value = node;
  }
  let pointerStartRef;
  let swipeDeltaRef;
  const duration = () => props.duration?.() || context.duration;
  let closeTimerStartTimeRef = 0;
  let closeTimerRemainingTimeRef = duration();
  let closeTimerRef = 0;
  const { onToastAdd, onToastRemove } = context;
  function handleClose() {
    const isFocusInToast = contextToastRoot.el.value?.contains(document.activeElement);
    if (isFocusInToast)
      context.viewport.value?.focus();
    contextToastRoot.onChangeOpen(false);
  }
  contextToastRoot.setOnClose(handleClose);
  function startTimer(duration2) {
    if (!duration2 || duration2 === Infinity)
      return;
    window.clearTimeout(closeTimerRef);
    closeTimerStartTimeRef = (/* @__PURE__ */ new Date()).getTime();
    closeTimerRef = window.setTimeout(handleClose, duration2);
  }
  function handleResume() {
    startTimer(closeTimerRemainingTimeRef);
    props.onResume?.();
  }
  function handlePause() {
    const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef;
    closeTimerRemainingTimeRef = closeTimerRemainingTimeRef - elapsedTime;
    window.clearTimeout(closeTimerRef);
    props.onPause?.();
  }
  watch(context.viewport, (viewport) => {
    if (!viewport)
      return;
    viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
    viewport.addEventListener(VIEWPORT_RESUME, handleResume);
    onWatcherCleanup(() => {
      viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
      viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
    });
  }, { immediate: true });
  if (isClient) {
    watchEffect(() => {
      if (!contextToastRoot.open.value || context.isClosePausedRef.value)
        return;
      startTimer(duration());
      onWatcherCleanup(() => {
        window.clearTimeout(closeTimerRef);
      });
    });
  }
  onMounted(() => {
    onToastAdd();
  });
  onBeforeUnmount(() => {
    onToastRemove();
  });
  const announceTextContent = computed(() => {
    if (!contextToastRoot.el.value)
      return void 0;
    let text = "";
    for (const item of getAnnounceTextContent(contextToastRoot.el.value)) {
      text += `${item} `;
    }
    return text;
  });
  function onSwipeStart(event) {
    props.onSwipeStart?.(event);
    if (event.defaultPrevented)
      return;
    event.currentTarget?.setAttribute("data-swipe", "start");
  }
  function onSwipeMove(event) {
    props.onSwipeMove?.(event);
    if (event.defaultPrevented)
      return;
    event.currentTarget.setAttribute("data-swipe", "move");
    event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${event.detail.delta.x}px`);
    event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${event.detail.delta.y}px`);
  }
  function onSwipeCancel(event) {
    props.onSwipeCancel?.(event);
    if (event.defaultPrevented)
      return;
    event.currentTarget.setAttribute("data-swipe", "cancel");
    event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
    event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
    event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
    event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
  }
  function onSwipeEnd(event) {
    props.onSwipeCancel?.(event);
    if (event.defaultPrevented)
      return;
    event.currentTarget.setAttribute("data-swipe", "end");
    event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
    event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
    event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${event.detail.delta.x}px`);
    event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${event.detail.delta.y}px`);
    contextToastRoot.onChangeOpen(false);
  }
  function onKeydown(event) {
    if (event.defaultPrevented)
      return;
    if (event.key !== "Escape")
      return;
    props.onEscapeKeydown?.(event);
    if (!event.defaultPrevented) {
      context.isFocusedToastEscapeKeyDownRef.value = true;
      handleClose();
    }
  }
  function onPointerdown(event) {
    if (event.defaultPrevented)
      return;
    if (event.button !== 0)
      return;
    pointerStartRef = { x: event.clientX, y: event.clientY };
  }
  function onPointermove(event) {
    if (event.defaultPrevented)
      return;
    if (!pointerStartRef)
      return;
    const x = event.clientX - pointerStartRef.x;
    const y = event.clientY - pointerStartRef.y;
    const hasSwipeMoveStarted = Boolean(swipeDeltaRef);
    const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection.value);
    const clamp = ["left", "up"].includes(context.swipeDirection.value) ? Math.min : Math.max;
    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;
    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;
    const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
    const delta = { x: clampedX, y: clampedY };
    const eventDetail = { originalEvent: event, delta };
    if (hasSwipeMoveStarted) {
      swipeDeltaRef = delta;
      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail);
    } else if (isDeltaInDirection(delta, context.swipeDirection.value, moveStartBuffer)) {
      swipeDeltaRef = delta;
      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail);
      event.target.setPointerCapture(event.pointerId);
    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
      pointerStartRef = void 0;
    }
  }
  function onPointerup(event) {
    if (event.defaultPrevented)
      return;
    const delta = swipeDeltaRef;
    const target = event.target;
    if (target.hasPointerCapture(event.pointerId)) {
      target.releasePointerCapture(event.pointerId);
    }
    swipeDeltaRef = void 0;
    pointerStartRef = void 0;
    if (!delta)
      return;
    const toast = event.currentTarget;
    const eventDetail = { originalEvent: event, delta };
    if (isDeltaInDirection(delta, context.swipeDirection.value, toValue(context.swipeThreshold))) {
      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail);
    } else {
      handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail);
    }
    const onClick = (event2) => {
      event2.preventDefault();
    };
    toast?.addEventListener("click", onClick, { once: true });
  }
  const dismissableLayer = useDismissableLayer(
    {
      el: contextToastRoot.el,
      disableOutsidePointerEvents() {
        return false;
      },
      onEscapeKeydown: props.onEscapeKeydown
    }
  );
  const style = {
    userSelect: "none",
    touchAction: "none"
  };
  return {
    type,
    viewport: context.viewport,
    announceTextContent,
    attrs(extraAttrs = []) {
      const attrs = {
        "elRef": setElRef,
        [DATA_COLLECTION_ITEM]: true,
        "role": "status",
        "aria-live": "off",
        "aria-atomic": true,
        "tabindex": 0,
        "data-state": contextToastRoot.open.value ? "open" : "closed",
        "data-swipe-direction": context.swipeDirection.value,
        "style": style,
        onKeydown,
        onPointerdown,
        onPointermove,
        onPointerup
      };
      return dismissableLayer.attrs([attrs, ...extraAttrs]);
    }
  };
}

const _hoisted_1 = ["aria-live"];
const _hoisted_2 = { key: 0 };
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ToastRootImpl",
    inheritAttrs: false
  },
  __name: "ToastRootImpl",
  props: {
    as: { default: "li" },
    type: { default: "foreground" },
    duration: {}
  },
  emits: ["escapeKeydown", "pause", "resume", "swipeStart", "swipeMove", "swipeEnd", "swipeCancel"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const toastRootImpl = useToastRootImpl(convertPropsToHookProps(
      props,
      ["duration"],
      () => ({
        onEscapeKeydown(event) {
          emit("escapeKeydown", event);
        },
        onPause() {
          emit("pause");
        },
        onResume() {
          emit("resume");
        },
        onSwipeStart(event) {
          emit("swipeStart", event);
        },
        onSwipeMove(event) {
          emit("swipeMove", event);
        },
        onSwipeEnd(event) {
          emit("swipeEnd", event);
        },
        onSwipeCancel(event) {
          emit("swipeCancel", event);
        }
      })
    ));
    const toastAnnounce = useToastAnnounce();
    return (_ctx, _cache) => {
      return unref(toastRootImpl).viewport.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        !unref(toastAnnounce).isAnnounced.value ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: "body"
        }, [
          unref(toastRootImpl).announceTextContent.value ? (openBlock(), createElementBlock("span", {
            key: 0,
            role: "status",
            "aria-live": unref(toastRootImpl).type === "foreground" ? "assertive" : "polite",
            "aria-atomic": "",
            style: normalizeStyle(unref(VISUALLY_HIDDEN_STYLE))
          }, [
            unref(toastAnnounce).renderAnnounceText.value ? (openBlock(), createElementBlock("span", _hoisted_2, toDisplayString(unref(toastAnnounce).label) + " " + toDisplayString(unref(toastRootImpl).announceTextContent.value), 1)) : createCommentVNode("", true)
          ], 12, _hoisted_1)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        (openBlock(), createBlock(Teleport, {
          to: unref(toastRootImpl).viewport.value
        }, [
          createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(toastRootImpl).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ], 8, ["to"]))
      ], 64)) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ToastRoot"
  },
  __name: "ToastRoot",
  props: /* @__PURE__ */ mergeDefaults({
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    forceMount: { type: Boolean }
  }, DEFAULT_TOAST_ROOT_PROPS),
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const toastRoot = useToastRoot(convertPropsToHookProps(
      props,
      ["open"],
      () => ({
        onUpdateOpen(open) {
          emit("update:open", open);
        }
      })
    ));
    return (_ctx, _cache) => {
      return unref(toastRoot).isPresent.value ? (openBlock(), createBlock(_sfc_main$2, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode("", true);
    };
  }
});

const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "ToastViewport",
    inheritAttrs: false
  },
  __name: "ToastViewport",
  props: {
    as: { default: "ol" },
    hotkey: { default: () => ["F8"] },
    label: { default: "Notifications ({hotkey})" }
  },
  setup(__props) {
    const props = __props;
    const toastViewport = useToastViewport(convertPropsToHookProps(props));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", normalizeProps(guardReactiveProps(unref(toastViewport).wrapperAttrs())), [
        unref(toastViewport).isShowFocusProxy.value ? (openBlock(), createElementBlock("span", normalizeProps(mergeProps({ key: 0 }, unref(toastViewport).headFocusProxy())), null, 16)) : createCommentVNode("", true),
        createVNode(unref(Primitive), normalizeProps(guardReactiveProps(unref(normalizeAttrs)(unref(toastViewport).attrs([_ctx.$attrs, { as: _ctx.as }])))), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16),
        unref(toastViewport).isShowFocusProxy.value ? (openBlock(), createElementBlock("span", normalizeProps(mergeProps({ key: 1 }, unref(toastViewport).tailFocusProxy())), null, 16)) : createCommentVNode("", true)
      ], 16);
    };
  }
});

export { _sfc_main$3 as _, useToastProviderContext as a, provideToastRootContext as b, useToastRootContext as c, _sfc_main$1 as d, _sfc_main as e, provideToastProviderContext as p, useToastProvider as u };
//# sourceMappingURL=toast.mjs.map
